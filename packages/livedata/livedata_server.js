Meteor._LivedataServer = function () {
  var self = this;

  self.publish_handlers = {};
  self.universal_publish_handlers = [];

  self.method_handlers = {};

  self.on_autopublish = []; // array of func if AP disabled, null if enabled
  self.warned_about_autopublish = false;

  self.stream_server = new Meteor._StreamServer;

  self.stream_server.register(function (socket) {
    socket.meteor = {};

    // Sub objects for active subscriptions
    socket.meteor.named_subs = {};
    socket.meteor.universal_subs = [];

    socket.on('data', function (raw_msg) {
      try {
        var msg = JSON.parse(raw_msg);
      } catch (err) {
        Meteor._debug("discarding message with invalid JSON", raw_msg);
        return;
      }
      if (typeof msg !== 'object' || !msg.msg) {
        Meteor._debug("discarding invalid livedata message", msg);
        return;
      }

      if (msg.msg === 'connect')
        self._livedata_connect(socket, msg);
      else if (msg.msg === 'sub')
        self._livedata_sub(socket, msg);
      else if (msg.msg === 'unsub')
        self._livedata_unsub(socket, msg);
      else if (msg.msg === 'method')
        self._livedata_method(socket, msg);
      else
        Meteor._debug("discarding unknown livedata message type", msg);
    });
  });
};

// ctor for a sub handle: the input to each publish function
Meteor._LivedataServer.SubHandle = function (socket, sub_id) {
  // transport.  provides send(obj).
  this.socket = socket;

  // my subscription ID (generated by client, null for universal subs).
  this.sub_id = sub_id;

  // unsent DDP messages.
  this.queue = [];

  // stop callbacks to g/c this sub.  called w/ zero arguments.
  this.stops = [];
};

Meteor._LivedataServer.SubHandle.prototype.stop = function () {
  for (var i = 0; i < this.stops.length; i++)
    (this.stops[i])();
};

Meteor._LivedataServer.SubHandle.prototype.on_stop = function (callback) {
  this.stops.push(callback);
};

// peek at the last message in the queue.  return it if it's a
// match, or create a new match on the queue and return that.
Meteor._LivedataServer.SubHandle.prototype._lastMsgOrNew = function (collection_name, id) {
  var self = this;
  var msg = self.queue.length && self.queue[self.queue.length - 1];
  if (!msg || msg.msg !== 'data' || msg.collection_name !== collection_name || msg.id !== id) {
    msg = {msg: 'data', collection: collection_name, id: id};
    self.queue.push(msg);
  }
  return msg;
};

Meteor._LivedataServer.SubHandle.prototype.set = function (collection_name, id, dictionary) {
  var self = this;
  var obj = _.extend({}, dictionary);
  delete obj['_id'];

  var msg = self._lastMsgOrNew(collection_name, id);
  msg.set = _.extend(msg.set || {}, obj);
};

Meteor._LivedataServer.SubHandle.prototype.unset = function (collection_name, id, keys) {
  var self = this;
  keys = _.without(keys, '_id');

  var msg = self._lastMsgOrNew(collection_name, id);
  msg.unset = _.union(msg.unset || [], keys);
};

Meteor._LivedataServer.SubHandle.prototype.satisfies_sub = function () {
  var self = this;
  var msg = self._lastMsgOrNew();
  msg.subs = msg.subs || [];
  msg.subs.push(self.sub_id);
};

Meteor._LivedataServer.SubHandle.prototype.flush = function () {
  var self = this;
  for (var i = 0; i < self.queue.length; i++) {
    self.socket.send(JSON.stringify(self.queue[i]));
    // Meteor._debug("LD DATA", self.sub_id, self.queue[i]);
  }
  self.queue = [];
};

Meteor._LivedataServer.SubHandle.prototype.publishCursor = function (cursor) {
  var self = this;

  // push all current data and flag as satisfying the sub.
  cursor.forEach(function (obj) {
    self.set(cursor.collection_name, obj._id, obj);
  });
  if (self.sub_id)
    self.satisfies_sub();
  self.flush();

  // callbacks to push future data.
  var observe_handle = cursor.observe({
    _suppress_initial: true,
    added: function (obj) {
      self.set(cursor.collection_name, obj._id, obj);
      self.flush();
    },
    changed: function (obj, old_idx, old_obj) {
      var set = {};
      _.each(obj, function (v, k) {
        // comparison doesn't have to be perfect, just means we send
        // extra bits.
        if (JSON.stringify(v) !== JSON.stringify(old_obj[k]))
          set[k] = v;
      });
      if (_.keys(set).length)
        self.set(cursor.collection_name, obj._id, set);
      var dead_keys = _.difference(_.keys(old_obj), _.keys(obj));
      if (dead_keys.length)
        self.unset(cursor.collection_name, obj._id, dead_keys);
      self.flush();
    },
    removed: function (id, old_idx, old_obj) {
      self.unset(cursor.collection_name, id, _.keys(old_obj));
      self.flush();
    }
  });

  // register stop callback (expects lambda w/ no args)
  self.on_stop(_.bind(observe_handle.stop, observe_handle));
};

_.extend(Meteor._LivedataServer.prototype, {
  // given a sub channel and a cursor, publish the results of that
  // cursor as a DDP stream.
  _startSubscription: function (socket, handler, sub_id, params) {
    var self = this;

    var sub = new Meteor._LivedataServer.SubHandle(socket, sub_id);
    if (sub_id)
      socket.meteor.named_subs[sub_id] = sub;
    else
      socket.meteor.universal_subs.push(sub);

    var res = handler(sub, params);

    // automatically wire up handlers that return a Cursor.
    // otherwise, the handler is completely responsible for delivering
    // its own data messages and registering stop functions.
    if (res instanceof _Mongo.Cursor) // XXX generalize
      sub.publishCursor(res);
  },

  // tear down specified subscription, or all subs if sub_id undefined
  _stopSubscription: function (socket, sub_id) {
    if (sub_id) {
      if (socket.meteor.named_subs[sub_id]) {
        socket.meteor.named_subs[sub_id].stop();
        delete socket.meteor.named_subs[sub_id];
      }
    } else {
      _.each(socket.meteor.named_subs, function (sub, id) {
        sub.stop();
      });
      _.each(socket.meteor.universal_subs, function (sub) {
        sub.stop();
      });
      socket.meteor.named_subs = {};
      socket.meteor.universal_subs = [];
    }
  },

  _livedata_connect: function (socket, msg) {
    var self = this;
    // Always start a new session. We don't support any reconnection.
    socket.send(JSON.stringify({msg: 'connected', session: Meteor.uuid()}));

    // Meteor._debug("LD CONNECT", msg);

    // Spin up all the universal publishers.
    Fiber(function () {
      _.each(self.universal_publish_handlers, function (handler) {
        self._startSubscription(socket, handler);
      });
    }).run();

    // XXX what to do here on reconnect?  oh, probably just fake a sub message.
  },

  _livedata_sub: function (socket, msg) {
    var self = this;

    // Meteor._debug("LD SUB", msg);

    if (!self.publish_handlers[msg.name]) {
      // can't sub to unknown publish name
      // XXX error value
      Meteor._debug("UNKNOWN NAME", msg.name);
      socket.send(JSON.stringify({
        msg: 'nosub', id: msg.id, error: {error: 17, reason: "Unknown name"}}));
      return;
    }

    Fiber(function () {
      if (msg.id)
        // XXX client screwed up
        self._stopSubscription(socket, msg.id);

      var handler = self.publish_handlers[msg.name];
      self._startSubscription(socket, handler, msg.id, msg.params);
    }).run();
  },

  _livedata_unsub: function (socket, msg) {
    var self = this;

    // Meteor._debug("LD UNSUB", msg);

    Fiber(function () {
      self._stopSubscription(socket, msg.id);
    }).run();

    socket.send(JSON.stringify({msg: 'nosub', id: msg.id}));
  },

  _livedata_method: function (socket, msg) {
    var self = this;
    // XXX note that running this in a fiber means that two serial
    // requests from the client can try to execute in parallel.. we're
    // going to have to think that through at some point. also, consider
    // races against Meteor.Collection(), though this shouldn't happen in
    // most normal use cases
    Fiber(function () {
      var func = msg.method && self.method_handlers[msg.method];
      if (!func) {
        socket.send(JSON.stringify({
          msg: 'result', id: msg.id,
          error: {error: 12, /* XXX error codes! */
                  reason: "Method not found"}}));
      } else {
        try {
          var result = func.apply(null, msg.params);
          socket.send(JSON.stringify({
            msg: 'result', id: msg.id, result: result}));
          socket.send(JSON.stringify({
            msg: 'data', methods: [msg.id]}));
        } catch (err) {
          socket.send(JSON.stringify({
            msg: 'result', id: msg.id,
            error: {error: 13, /* XXX error codes! */
                    reason: "Internal server error"}}));
          // XXX prettyprint exception in the log
          Meteor._debug("Exception in method '" + msg.method + "': " +
                        JSON.stringify(err.stack));
        }
      }
    }).run();
  },

  /**
   * Register a publish handler function.
   *
   * @param name {String} identifier for query
   * @param handler {Function} publish handler
   * @param options {Object}
   *

   * Server will call handler function on each new subscription,
   * either when receiving DDP sub message for a named subscription, or on
   * DDP connect for a universal subscription.
   *
   * If name is null, this will be a subscription that is
   * automatically established and permanently on for all connected
   * client, instead of a subscription that can be turned on and off
   * with subscribe().
   *
   * options to contain:
   *  - (mostly internal) is_auto: true if generated automatically
   *    from an autopublish hook. this is for cosmetic purposes only
   *    (it lets us determine whether to print a warning suggesting
   *    that you turn off autopublish.)
   */
  publish: function (name, handler, options) {
    var self = this;

    options = options || {};

    if (name && name in self.publish_handlers) {
      Meteor._debug("ERROR DUPLICATE PUBLISH " + name);
      return;
    }

    if (!self.on_autopublish && !options.is_auto) {
      // They have autopublish on, yet they're trying to manually
      // picking stuff to publish. They probably should turn off
      // autopublish. (This check isn't perfect -- if you create a
      // publish before you turn on autopublish, it won't catch
      // it. But this will definitely handle the simple case where
      // you've added the autopublish package to your app, and are
      // calling publish from your app code.)
      if (!self.warned_about_autopublish) {
        self.warned_about_autopublish = true;
        Meteor._debug(
"** You've set up some data subscriptions with Meteor.publish(), but\n" +
"** you still have autopublish turned on. Because autopublish is still\n" +
"** on, your Meteor.publish() calls won't have much effect. All data\n" +
"** will still be sent to all clients.\n" +
"**\n" +
"** Turn off autopublish by removing the autopublish package:\n" +
"**\n" +
"**   $ meteor remove autopublish\n" +
"**\n" +
"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\n" +
"** for each collection that you want clients to see.\n");
      }
    }

    if (name)
      self.publish_handlers[name] = handler;
    else
      self.universal_publish_handlers.push(handler);
  },

  methods: function (methods) {
    var self = this;
    _.each(methods, function (func, name) {
      if (self.method_handlers[name])
        throw new Error("A method named '" + name + "' is already defined");
      self.method_handlers[name] = func;
    });
  },

  call: function (name /*, arguments */) {
    return this.apply(name, Array.prototype.slice.call(arguments, 1));
  },

  apply: function (name, args) {
    var self = this;
    var handler = self.method_handlers[name];
    if (!handler)
      throw new Error("No such method '" + name + "'");

    args = _.clone(args);
    var result_func;
    if (args.length && typeof args[args.length - 1] === "function")
      result_func = args.pop();

    /*
       var user_id =
       (Fiber.current && Fiber.current._meteor_livedata_user_id) || null;
      args.unshift(user_id);
    */
    var ret = handler.apply(null, args);
    if (result_func)
      result_func(ret); // XXX catch exception?
    return ret;
  },

  // A much more elegant way to do this would be: let any autopublish
  // provider (eg, mongo-livedata) declare a weak package dependency
  // on the autopublish package, then have that package simply set a
  // flag that eg the Collection constructor checks, and autopublishes
  // if necessary.
  autopublish: function () {
    var self = this;
    _.each(self.on_autopublish || [], function (f) { f(); });
    self.on_autopublish = null;
  },

  onAutopublish: function (f) {
    var self = this;
    if (self.on_autopublish)
      self.on_autopublish.push(f);
    else
      f();
  }
});
