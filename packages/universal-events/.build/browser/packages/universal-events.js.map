{"version":3,"file":"/packages/universal-events.js","sources":["universal-events/listener.js","universal-events/events-w3c.js","universal-events/events-ie.js"],"names":[],"mappings":";;;;;;;;AAAA,6E;AACA,E;AACA,+D;AACA,mE;AACA,mE;AACA,iE;AACA,sE;AACA,kE;AACA,0D;AACA,E;AACA,iE;AACA,yD;AACA,kE;AACA,c;AACA,E;AACA,S;AACA,yE;AACA,+B;AACA,E;AACA,oE;AACA,oE;AACA,+C;AACA,E;AACA,kE;AACA,mE;AACA,mE;AACA,sE;AACA,iE;AACA,E;AACA,wB;AACA,E;AACA,qE;AACA,gE;AACA,yD;AACA,kE;;AAEA,mB;;AAEA,+C;AACA,6C;;AAEA,2B;AACA,uC;AACA,sD;AACA,oD;AACA,2C;AACA,oD;AACA,yC;AACA,sC;AACA,4C;AACA,gC;AACA,0C;AACA,Q;AACA,sC;AACA,I;AACA,qC;AACA,0C;AACA,+B;AACA,yC;AACA,Q;AACA,sC;AACA,I;AACA,+C;AACA,4B;AACA,qD;AACA,I;;AAEA,wB;;AAEA,wB;AACA,kC;AACA,kC;AACA,0B;AACA,iB;AACA,2D;AACA,gE;AACA,4D;AACA,6C;AACA,gD;AACA,4B;AACA,8E;AACA,yD;AACA,mB;AACA,sC;AACA,mD;AACA,iE;AACA,kE;AACA,iE;AACA,uD;AACA,gC;AACA,qC;AACA,sC;AACA,+C;AACA,K;AACA,G;;AAEA,e;AACA,E;;AAEA,gC;AACA,gC;AACA,yC;AACA,qC;AACA,kE;AACA,wD;AACA,0C;AACA,4E;AACA,2C;AACA,K;AACA,K;AACA,E;;AAEA,0D;AACA,S;AACA,2B;AACA,a;AACA,uC;AACA,2D;AACA,0D;AACA,c;AACA,E;;AAEA,oB;;;AAGA,qB;;AAEA,8D;AACA,mE;AACA,+B;AACA,E;AACA,kE;AACA,4D;AACA,2D;AACA,iE;AACA,mE;AACA,8D;AACA,qC;AACA,E;AACA,iE;AACA,+D;AACA,W;AACA,E;AACA,wB;AACA,W;AACA,kB;AACA,sB;AACA,qB;AACA,2B;AACA,yB;AACA,E;AACA,iE;AACA,sE;AACA,oC;AACA,E;AACA,kB;AACA,E;AACA,mE;AACA,mE;AACA,mE;AACA,mE;AACA,yD;AACA,iE;AACA,yB;AACA,wD;AACA,wB;AACA,+C;AACA,uB;AACA,E;;AAEA,4C;AACA,kE;AACA,mE;AACA,2B;AACA,4B;AACA,4B;AACA,8B;AACA,qD;AACA,iC;AACA,gC;AACA,K;AACA,I;;AAEA,kE;AACA,wE;AACA,uB;AACA,+B;AACA,2B;AACA,8B;AACA,yB;AACA,6B;AACA,mC;AACA,K;AACA,I;;AAEA,oE;AACA,kE;AACA,oE;AACA,mE;AACA,yC;AACA,I;AACA,+D;AACA,kE;AACA,kE;AACA,oE;AACA,gE;AACA,gC;AACA,I;AACA,sE;AACA,kC;AACA,I;AACA,+D;AACA,mE;AACA,iE;AACA,8B;AACA,yC;AACA,mE;AACA,4B;AACA,a;AACA,yC;;AAEA,iF;AACA,qE;AACA,gE;AACA,wE;AACA,U;AACA,kC;AACA,+D;AACA,oE;AACA,sE;AACA,wE;AACA,mD;AACA,4B;AACA,4D;AACA,iD;AACA,W;AACA,O;AACA,K;AACA,I;;AAEA,iE;AACA,mB;AACA,wB;AACA,oB;;AAEA,2C;AACA,gD;AACA,4B;AACA,O;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC1PA,gE;AACA,qE;AACA,2B;AACA,E;AACA,qE;AACA,uE;AACA,mE;AACA,iD;;AAEA,yB;AACA,4B;AACA,kC;;AAEA,mE;;AAEA,Y;AACA,uD;AACA,yB;AACA,4D;;AAEA,iD;AACA,mD;;AAEA,kE;AACA,gE;AACA,oC;AACA,I;AACA,+D;AACA,mE;AACA,mE;AACA,iE;AACA,+D;AACA,I;AACA,kE;AACA,wC;AACA,I;AACA,mE;AACA,8D;AACA,iE;AACA,mE;AACA,mB;AACA,uE;AACA,iD;;AAEA,oE;AACA,uD;AACA,4E;AACA,kD;AACA,E;;AAEA,sD;AACA,iC;AACA,mD;AACA,I;;AAEA,+B;AACA,gD;AACA,I;;AAEA,yC;AACA,wC;AACA,I;;AAEA,qC;AACA,qB;;AAEA,kE;AACA,sD;;AAEA,qD;AACA,2B;AACA,4B;AACA,+B;AACA,6B;AACA,kE;AACA,6B;AACA,0B;AACA,mC;AACA,yB;AACA,K;AACA,uC;AACA,gC;AACA,8B;AACA,qC;AACA,6B;AACA,K;;AAEA,yB;AACA,4B;AACA,2B;AACA,K;;AAEA,e;AACA,I;;AAEA,6B;AACA,oB;AACA,mC;AACA,2E;AACA,kE;AACA,O;AACA,I;;AAEA,+B;AACA,oB;AACA,mC;AACA,uC;AACA,qE;AACA,O;AACA,O;AACA,I;;AAEA,8B;AACA,4D;AACA,6C;;AAEA,0B;AACA,gC;AACA,8B;;AAEA,4D;;AAEA,oE;AACA,iE;AACA,iE;AACA,+B;AACA,kB;AACA,kB;AACA,qB;AACA,2D;AACA,2D;AACA,0B;AACA,Q;AACA,K;;AAEA,iC;AACA,2B;AACA,iE;AACA,oB;AACA,uC;AACA,gE;AACA,W;AACA,Q;AACA,U;AACA,I;;AAEA,6B;AACA,4E;AACA,iD;AACA,iE;AACA,2B;AACA,gC;AACA,M;;AAEA,kE;AACA,+C;AACA,uD;AACA,qC;AACA,oD;AACA,2C;AACA,mD;AACA,oE;AACA,mC;AACA,qD;AACA,uC;AACA,sD;AACA,O;AACA,K;AACA,kE;AACA,qD;AACA,4D;AACA,8B;AACA,iB;AACA,O;AACA,kE;AACA,kE;AACA,8B;AACA,iB;AACA,O;AACA,K;AACA,uC;AACA,uE;AACA,8B;AACA,iB;AACA,O;AACA,K;;AAEA,wB;;AAEA,qD;AACA,uC;AACA,wD;AACA,kE;AACA,kD;AACA,yD;AACA,uD;AACA,sD;AACA,iC;AACA,wD;AACA,qC;AACA,0D;AACA,uC;AACA,8D;AACA,O;AACA,2C;AACA,8D;AACA,O;AACA,K;;AAEA,qC;AACA,6C;AACA,K;AACA,oC;AACA,6C;AACA,sD;AACA,O;AACA,6C;AACA,K;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC3NA,kE;AACA,wC;AACA,E;AACA,mE;AACA,kE;AACA,iE;AACA,kE;AACA,qE;AACA,E;AACA,qE;AACA,qE;AACA,+D;AACA,4D;AACA,oE;AACA,4D;AACA,E;AACA,uE;AACA,kE;AACA,iE;AACA,uD;;AAEA,mE;;AAEA,Y;AACA,sD;AACA,kB;AACA,yB;AACA,qC;AACA,kC;AACA,I;;AAEA,kE;AACA,mE;AACA,uE;AACA,uE;AACA,sB;AACA,yD;AACA,2B;AACA,uC;AACA,kC;AACA,qC;AACA,kC;AACA,gE;AACA,gE;AACA,sB;AACA,K;AACA,E;;AAEA,qD;AACA,4B;AACA,2B;AACA,I;;AAEA,+B;AACA,2B;AACA,I;;AAEA,yC;AACA,mD;AACA,yD;AACA,+C;AACA,2B;;AAEA,yC;AACA,gC;;AAEA,gE;AACA,uD;;AAEA,oD;AACA,4C;AACA,K;AACA,I;;AAEA,mC;AACA,uB;;AAEA,0D;AACA,2B;AACA,8B;AACA,+B;AACA,+B;AACA,yD;AACA,mC;AACA,wD;AACA,kD;AACA,sC;AACA,8D;AACA,qC;AACA,iC;AACA,mC;AACA,sC;;AAEA,yC;AACA,2C;AACA,I;;AAEA,2E;AACA,8E;AACA,I;AACA,uE;AACA,mE;AACA,+C;AACA,4B;AACA,+C;AACA,2C;AACA,yB;AACA,kC;AACA,2B;AACA,M;;;AAGA,6B;AACA,0B;AACA,8C;AACA,0B;AACA,4B;AACA,4E;AACA,+B;AACA,uB;;AAEA,wD;AACA,kD;AACA,yE;AACA,wE;AACA,yE;AACA,2C;AACA,kD;AACA,6B;AACA,sC;AACA,mC;AACA,qC;AACA,iC;AACA,2C;AACA,2C;AACA,6C;AACA,6C;AACA,qC;AACA,gD;AACA,O;AACA,K;AACA,uD;AACA,kD;AACA,sC;AACA,yD;AACA,kC;AACA,8E;AACA,a;AACA,K;;AAEA,sB;AACA,mD;AACA,mC;AACA,K;AACA,wD;AACA,mC;AACA,K;;AAEA,wB;AACA,G;;AAEA,G","sourcesContent":["// Meteor Universal Events -- Normalized cross-browser event handling library\n//\n// This module lets you set up a function f that will be called\n// whenever an event fires on any element in the DOM. Specifically,\n// when an event fires on node N, f will be called with N. Then, if\n// the event is a bubbling event, f will be called again with N's\n// parent, then called again with N's grandparent, etc, until the root\n// of the document is reached. This provides a good base on top of\n// which custom event handling systems can be implemented.\n//\n// f also receives the event object for the event that fired. The\n// event object is normalized and extended to smooth over\n// cross-browser differences in event handling. See the details in\n// setHandler.\n//\n// Usage:\n//   var listener = new UniversalEventListener(function (event) { ... });\n//   listener.addType(\"click\");\n//\n// If you want to support IE <= 8, you must also call installHandler\n// on each subtree of DOM nodes on which you wish to receive events,\n// eg, before inserting them into the document.\n//\n// Universal Events works reliably for events that fire on any DOM\n// element. It may not work consistently across browsers for events\n// that are intended to fire on non-element nodes (eg, text nodes).\n// We're not sure if it's possible to handle those events consistently\n// across browsers, but in any event, it's not a common use case.\n//\n// Implementation notes:\n//\n// Internally, there are two separate implementations, one for modern\n// browsers (in events-w3c.js), and one for old browsers with no\n// event capturing support (in events-ie.js.) The correct\n// implementation will be chosen for you automatically at runtime.\n\nvar listeners = [];\n\nvar returnFalse = function() { return false; };\nvar returnTrue = function() { return true; };\n\n// inspired by jquery fix()\nvar normalizeEvent = function (event) {\n  var originalStopPropagation = event.stopPropagation;\n  var originalPreventDefault = event.preventDefault;\n  event.isPropagationStopped = returnFalse;\n  event.isImmediatePropagationStopped = returnFalse;\n  event.isDefaultPrevented = returnFalse;\n  event.stopPropagation = function() {\n    event.isPropagationStopped = returnTrue;\n    if (originalStopPropagation)\n      originalStopPropagation.call(event);\n    else\n      event.cancelBubble = true; // IE\n  };\n  event.preventDefault = function() {\n    event.isDefaultPrevented = returnTrue;\n    if (originalPreventDefault)\n      originalPreventDefault.call(event);\n    else\n      event.returnValue = false; // IE\n  };\n  event.stopImmediatePropagation = function() {\n    event.stopPropagation();\n    event.isImmediatePropagationStopped = returnTrue;\n  };\n\n  var type = event.type;\n\n  // adapted from jquery\n  if (event.metaKey === undefined)\n    event.metaKey = event.ctrlKey;\n  if (/^key/.test(type)) {\n    // KEY EVENTS\n    // Add which.  Technically char codes and key codes are\n    // different things; the former is ASCII/unicode/etc and the\n    // latter is arbitrary.  But browsers that lack charCode\n    // seem to put character info in keyCode.\n    // (foo == null) tests for null or undefined\n    if (event.which == null)\n      event.which = (event.charCode != null ? event.charCode : event.keyCode);\n  } else if (/^(?:mouse|contextmenu)|click/.test(type)) {\n    // MOUSE EVENTS\n    // Add relatedTarget, if necessary\n    if (! event.relatedTarget && event.fromElement)\n      event.relatedTarget = (event.fromElement === event.target ?\n                             event.toElement : event.fromElement);\n    // Add which for click: 1 === left; 2 === middle; 3 === right\n    if (! event.which && event.button !== undefined ) {\n      var button = event.button;\n      event.which = (button & 1 ? 1 :\n                     (button & 2 ? 3 :\n                       (button & 4 ? 2 : 0 )));\n    }\n  }\n\n  return event;\n};\n\nvar deliver = function (event) {\n  event = normalizeEvent(event);\n  _.each(listeners, function (listener) {\n    if (listener.types[event.type]) {\n      // if in debug mode, filter out events where the user forgot\n      // to call installHandler, even if we're not on IE\n      if (!(listener._checkIECompliance &&\n            ! event.currentTarget['_uevents_test_eventtype_' + event.type]))\n        listener.handler.call(null, event);\n    }\n  });\n};\n\n// When IE8 is dead, we can remove this springboard logic.\nvar impl;\nvar getImpl = function () {\n  if (! impl)\n    impl = (document.addEventListener ?\n            new UniversalEventListener._impl.w3c(deliver) :\n            new UniversalEventListener._impl.ie(deliver));\n  return impl;\n};\n\nvar typeCounts = {};\n\n\n////////// PUBLIC API\n\n// Create a new universal event listener with a given handler.\n// Until some event types are turned on with `addType`, the handler\n// will not receive any events.\n//\n// Whenever an event of the appropriate type fires anywhere in the\n// document, `handler` will be called with one argument, the\n// event. If the event is a bubbling event (most events are\n// bubbling, eg, 'click'), then `handler` will be called not only\n// for the element that was the origin of the event (eg, the button\n// that was clicked), but for each parent element as the event\n// bubbles up to the top of the tree.\n//\n// The event object that's passed to `handler` will be normalized\n// across browsers so that it contains the following fields and\n// methods:\n//\n// - type (e.g. \"click\")\n// - target\n// - currentTarget\n// - stopPropagation()\n// - preventDefault()\n// - isPropagationStopped()\n// - isDefaultPrevented()\n//\n// NOTE: If you want compatibility with IE <= 8, you will need to\n// call `installHandler` to prepare each subtree of the DOM to receive\n// the events you are interested in.\n//\n// Debugging only:\n//\n// The _checkIECompliance flag enables extra checking that the user\n// is correctly registering new DOM nodes with installHandler, even\n// in browsers that don't require it. In other words, when the flag\n// is set, modern browsers will require the same API calls as IE <=\n// 8. This is only used for tests and is private for now.\nUniversalEventListener = function (handler, _checkIECompliance) {\n  this.handler = handler;\n  this.types = {}; // map from event type name to 'true'\n  this.impl = getImpl();\n  this._checkIECompliance = _checkIECompliance;\n  listeners.push(this);\n};\n\n_.extend(UniversalEventListener.prototype, {\n  // Adds `type` to the set of event types that this listener will\n  // listen to and deliver to the handler.  Has no effect if `type`\n  // is already in the set.\n  addType: function (type) {\n    if (!this.types[type]) {\n      this.types[type] = true;\n      typeCounts[type] = (typeCounts[type] || 0) + 1;\n      if (typeCounts[type] === 1)\n        this.impl.addType(type);\n    }\n  },\n\n  // Removes `type` from the set of event types that this listener\n  // will listen to and deliver to the handler.  Has no effect if `type`\n  // is not in the set.\n  removeType: function (type) {\n    if (this.types[type]) {\n      delete this.types[type];\n      typeCounts[type]--;\n      if (! typeCounts[type])\n        this.impl.removeType(type);\n    }\n  },\n\n  // It is only necessary to call this method if you want to support\n  // IE <= 8. On those browsers, you must call this method on each\n  // set of nodes before adding them to the DOM (or at least, before\n  // expecting to receive events on them), and you must specify the\n  // types of events you'll be receiving.\n  //\n  // `node` and all of its descendents will be set up to handle\n  // events of type `type` (eg, 'click'). Only current descendents\n  // of `node` are affected; if new nodes are added to the subtree\n  // later, installHandler must be called again to ensure events are\n  // received on those nodes. To set up to handle multiple event\n  // types, make multiple calls.\n  //\n  // It is safe to call installHandler any number of times on the same\n  // arguments (it is idempotent).\n  //\n  // If you forget to call this function for a given node, it's\n  // unspecified whether you'll receive events on IE <= 8 (you may,\n  // you may not.) If you don't care about supporting IE <= 8 you\n  // can ignore this function.\n  installHandler: function (node, type) {\n    // Only work on element nodes, not e.g. text nodes or fragments\n    if (node.nodeType !== 1)\n      return;\n    this.impl.installHandler(node, type);\n\n    // When in checkIECompliance mode, mark all the nodes in the current subtree.\n    // We will later block events on nodes that weren't marked.  This\n    // tests that Spark is generating calls to registerEventType\n    // with proper subtree information, even in browsers that don't need\n    // it.\n    if (this._checkIECompliance) {\n      // set flag to mark the node for this type, recording the\n      // fact that installHandler was called for this node and type.\n      // the property value can be any non-primitive value (to prevent\n      // showing up as an HTML attribute in IE) so we use `node` itself.\n      node['_uevents_test_eventtype_'+type] = node;\n      if (node.firstChild) {\n        _.each(node.getElementsByTagName('*'), function(x) {\n          x['_uevents_test_eventtype_'+type] = x;\n        });\n      }\n    }\n  },\n\n  // Tear down this UniversalEventListener so that no more events\n  // are delivered.\n  destroy: function () {\n    var self = this;\n\n    listeners = _.without(listeners, self);\n    _.each(_.keys(self.types), function (type) {\n      self.removeType(type);\n    });\n  }\n});\n","// Universal Events implementation that depends on the W3C event\n// model, i.e. addEventListener and capturing.  It's intended for all\n// browsers except IE <= 8.\n//\n// We take advantage of the fact that event handlers installed during\n// the capture phase are live during the bubbling phase.  By installing\n// a capturing listener on the document, we bind the handler to the\n// event target and its ancestors \"just in time\".\n\nvar SIMULATE_NEITHER = 0;\nvar SIMULATE_FOCUS_BLUR = 1;\nvar SIMULATE_FOCUSIN_FOCUSOUT = 2;\n\nUniversalEventListener._impl = UniversalEventListener._impl ||  {};\n\n// Singleton\nUniversalEventListener._impl.w3c = function (deliver) {\n  this.deliver = deliver;\n  this.typeCounts = {}; // map from event type name to count\n\n  this.boundHandler = _.bind(this.handler, this);\n  this.boundCapturer = _.bind(this.capturer, this);\n\n  // Focusin/focusout are the bubbling versions of focus/blur, and\n  // are part of the W3C spec, but are absent from Firefox as of\n  // today (v11), so we supply them.\n  //\n  // In addition, while most browsers fire these events sync in\n  // response to a programmatic action (like .focus()), not all do.\n  // IE 9+ fires focusin/focusout sync but focus/blur async.  Opera\n  // fires them all async.  We don't do anything about this right\n  // now, but simulating focus/blur on IE would make them sync.\n  //\n  // We have the capabiilty here to simulate focusin/focusout from\n  // focus/blur, vice versa, or neither.\n  //\n  // We do a browser check that fails in old Firefox (3.6) but will\n  // succeed if Firefox ever implements focusin/focusout.  Old\n  // Firefox fails all tests of the form ('onfoo' in node), while\n  // new Firefox and all other known browsers will pass if 'foo' is\n  // a known event.\n  this.focusBlurMode = ('onfocusin' in document.createElement(\"DIV\")) ?\n    SIMULATE_NEITHER : SIMULATE_FOCUSIN_FOCUSOUT;\n\n  // mouseenter/mouseleave is non-bubbling mouseover/mouseout.  It's\n  // standard but only IE and Opera seem to support it,\n  // so we simulate it (which works in IE but not in Opera for some reason).\n  this.simulateMouseEnterLeave = (! window.opera);\n};\n\n_.extend(UniversalEventListener._impl.w3c.prototype, {\n  addType: function (eventType) {\n    this._listen(this._expandEventType(eventType));\n  },\n\n  removeType: function (type) {\n    this._unlisten(this._expandEventType(type));\n  },\n\n  installHandler: function (node, type) {\n    // Unnecessary in w3c implementation\n  },\n\n  _expandEventType: function (type) {\n    var ret = [type];\n\n    // install handlers for the events used to fake events of this\n    // type, in addition to handlers for the real type\n\n    if (this.focusBlurMode === SIMULATE_FOCUS_BLUR) {\n      if (type === 'focus')\n        ret.push('focusin');\n      else if (type === 'blur')\n        ret.push('focusout');\n    } else if (this.focusBlurMode === SIMULATE_FOCUSIN_FOCUSOUT) {\n      if (type === 'focusin')\n        ret.push('focus');\n      else if (type === 'focusout')\n        ret.push('blur');\n    }\n    if (this.simulateMouseEnterLeave) {\n      if (type === 'mouseenter')\n        ret.push('mouseover');\n      else if (type === 'mouseleave')\n        ret.push('mouseout');\n    }\n\n    if (type === 'tap') {\n      ret.push('touchmove');\n      ret.push('touchend');\n    }\n\n    return ret;\n  },\n\n  _listen: function (types) {\n    var self = this;\n    _.each(types, function (type) {\n      if ((self.typeCounts[type] = (self.typeCounts[type] || 0) + 1) === 1)\n        document.addEventListener(type, self.boundCapturer, true);\n    });\n  },\n\n  _unlisten: function (types) {\n    var self = this;\n    _.each(types, function (type) {\n      if (!(--self.typeCounts[type])) {\n        document.removeEventListener(type, self.boundCapturer, true);\n      }\n    });\n  },\n\n  capturer: function (event) {\n    if (event.target.nodeType === 3) // fix text-node target\n      event.target = event.target.parentNode;\n\n    var type = event.type;\n    var bubbles = event.bubbles;\n    var target = event.target;\n\n    target.addEventListener(type, this.boundHandler, false);\n\n    // According to the DOM event spec, if the DOM is mutated during\n    // event handling, the original bubbling order still applies.\n    // So we can determine the chain of nodes that could possibly\n    // be bubbled to right now.\n    var ancestors;\n    if (bubbles) {\n      ancestors = [];\n      for(var n = target.parentNode; n; n = n.parentNode) {\n        n.addEventListener(type, this.boundHandler, false);\n        ancestors.push(n);\n      };\n    }\n\n    // Unbind the handlers later.\n    setTimeout(function() {\n      target.removeEventListener(type, this.boundHandler, false);\n      if (bubbles) {\n        _.each(ancestors, function(n) {\n          n.removeEventListener(type, this.boundHandler, false);\n        });\n      };\n    }, 0);\n  },\n\n  handler: function (event) {\n    var sendUIEvent = function (type, target, bubbles, cancelable, detail) {\n      var evt = document.createEvent(\"UIEvents\");\n      evt.initUIEvent(type, bubbles, cancelable, window, detail);\n      evt.synthetic = true;\n      target.dispatchEvent(evt);\n    };\n\n    // fire synthetic focusin/focusout on blur/focus or vice versa\n    if (event.currentTarget === event.target) {\n      if (this.focusBlurMode === SIMULATE_FOCUS_BLUR) {\n        if (event.type === 'focusin')\n          sendUIEvent('focus', event.target, false);\n        else if (event.type === 'focusout')\n          sendUIEvent('blur', event.target, false);\n      } else if (this.focusBlurMode === SIMULATE_FOCUSIN_FOCUSOUT) {\n        if (event.type === 'focus')\n          sendUIEvent('focusin', event.target, true);\n        else if (event.type === 'blur')\n          sendUIEvent('focusout', event.target, true);\n      }\n    }\n    // only respond to synthetic events of the types we are faking\n    if (this.focusBlurMode === SIMULATE_FOCUS_BLUR) {\n      if (event.type === 'focus' || event.type === 'blur') {\n        if (! event.synthetic)\n          return;\n      }\n    } else if (this.focusBlurMode === SIMULATE_FOCUSIN_FOCUSOUT) {\n      if (event.type === 'focusin' || event.type === 'focusout') {\n        if (! event.synthetic)\n          return;\n      }\n    }\n    if (this.simulateMouseEnterLeave) {\n      if (event.type === 'mouseenter' || event.type === 'mouseleave') {\n        if (! event.synthetic)\n          return;\n      }\n    }\n\n    this.deliver(event);\n\n    // event ordering: fire mouseleave after mouseout\n    if (this.simulateMouseEnterLeave &&\n        // We respond to mouseover/mouseout here even on\n        // bubble, i.e. when event.currentTarget !== event.target,\n        // to ensure we see every enter and leave.\n        // We ignore the case where the mouse enters from\n        // a child or leaves to a child (by checking if\n        // relatedTarget is present and a descendent).\n        (! event.relatedTarget ||\n         (event.currentTarget !== event.relatedTarget &&\n          ! DomUtils.elementContains(\n            event.currentTarget, event.relatedTarget)))) {\n      if (event.type === 'mouseover') {\n        sendUIEvent('mouseenter', event.currentTarget, false);\n      }\n      else if (event.type === 'mouseout') {\n        sendUIEvent('mouseleave', event.currentTarget, false);\n      }\n    }\n\n    if (event.type === 'touchmove') {\n      event.currentTarget._notTapping = true;\n    }\n    if (event.type === 'touchend') {\n      if (!event.currentTarget._notTapping) {\n        sendUIEvent('tap', event.currentTarget, true);\n      }\n      delete event.currentTarget._notTapping;\n    }\n  }\n});\n","// Universal Events implementation for IE versions 6-8, which lack\n// addEventListener and event capturing.\n//\n// The strategy is very different.  We walk the subtree in question\n// and just attach the handler to all elements.  If the handler is\n// foo and the eventType is 'click', we assign node.onclick = foo\n// everywhere.  Since there is only one function object and we are\n// just assigning a property, hopefully this is somewhat lightweight.\n//\n// We use the node.onfoo method of binding events, also called \"DOM0\"\n// or the \"traditional event registration\", rather than the IE-native\n// node.attachEvent(...), mainly because we have the benefit of\n// referring to `this` from the handler in order to populate\n// event.currentTarget.  It seems that otherwise we'd have to create\n// a closure per node to remember what node we are handling.\n//\n// We polyfill the usual event properties from their various locations.\n// We also make 'change' and 'submit' bubble, and we fire 'change'\n// events on checkboxes and radio buttons immediately rather than\n// only when the user blurs them, another old IE quirk.\n\nUniversalEventListener._impl = UniversalEventListener._impl ||  {};\n\n// Singleton\nUniversalEventListener._impl.ie = function (deliver) {\n  var self = this;\n  this.deliver = deliver;\n  this.curriedHandler = function () {\n    self.handler.call(this, self);\n  };\n\n  // The 'submit' event on IE doesn't bubble.  We want to simulate\n  // bubbling submit to match other browsers, and to do that we use\n  // IE's own event machinery.  We can't dispatch events with arbitrary\n  // names in IE, so we appropriate the obscure \"datasetcomplete\" event\n  // for this purpose.\n  document.attachEvent('ondatasetcomplete', function () {\n    var evt = window.event;\n    var target = evt && evt.srcElement;\n    if (evt.synthetic && target &&\n        target.nodeName === 'FORM' &&\n        evt.returnValue !== false)\n      // No event handler called preventDefault on the simulated\n      // submit event.  That means the form should be submitted.\n      target.submit();\n  });\n};\n\n_.extend(UniversalEventListener._impl.ie.prototype, {\n  addType: function (type) {\n    // not necessary for IE\n  },\n\n  removeType: function (type) {\n    // not necessary for IE\n  },\n\n  installHandler: function (node, type) {\n    // use old-school event binding, so that we can\n    // access the currentTarget as `this` in the handler.\n    // note: handler is never removed from node\n    var prop = 'on' + type;\n\n    if (node.nodeType === 1) { // ELEMENT\n      this._install(node, prop);\n\n      // hopefully fast traversal, since the browser is doing it\n      var descendents = node.getElementsByTagName('*');\n\n      for(var i=0, N = descendents.length; i<N; i++)\n        this._install(descendents[i], prop);\n    }\n  },\n\n  _install: function (node, prop) {\n    var props = [prop];\n\n    // install handlers for faking focus/blur if necessary\n    if (prop === 'onfocus')\n      props.push('onfocusin');\n    else if (prop === 'onblur')\n      props.push('onfocusout');\n    // install handlers for faking bubbling change/submit\n    else if (prop === 'onchange') {\n      // if we're looking at a checkbox or radio button,\n      // sign up for propertychange and NOT change\n      if (node.nodeName === 'INPUT' &&\n          (node.type === 'checkbox' || node.type === 'radio'))\n        props = ['onpropertychange'];\n      props.push('oncellchange');\n    } else if (prop === 'onsubmit')\n      props.push('ondatasetcomplete');\n\n    for(var i = 0; i < props.length; i++)\n      node[props[i]] = this.curriedHandler;\n  },\n\n  // This is the handler we assign to DOM nodes, so it shouldn't close over\n  // anything that would create a circular reference leading to a memory leak.\n  //\n  // This handler is called via this.curriedHandler. When it is called:\n  //  - 'this' is the node currently handling the event (set by IE)\n  //  - 'self' is what would normally be 'this'\n  handler: function (self) {\n    var sendEvent = function (ontype, target) {\n      var e = document.createEventObject();\n      e.synthetic = true;\n      target.fireEvent(ontype, e);\n      return e.returnValue;\n    };\n\n\n    var event = window.event;\n    var type = event.type;\n    var target = event.srcElement || document;\n    event.target = target;\n    if (this.nodeType !== 1)\n      return; // sanity check that we have a real target (always an element)\n    event.currentTarget = this;\n    var curNode = this;\n\n    // simulate focus/blur so that they are synchronous;\n    // simulate change/submit so that they bubble.\n    // The IE-specific 'cellchange' and 'datasetcomplete' events actually\n    // have nothing to do with change and submit, we are just using them\n    // as dummy events because we need event types that IE considers real\n    // (and apps are unlikely to use them).\n    if (curNode === target && ! event.synthetic) {\n      if (type === 'focusin')\n        sendEvent('onfocus', curNode);\n      else if (type === 'focusout')\n        sendEvent('onblur', curNode);\n      else if (type === 'change')\n        sendEvent('oncellchange', curNode);\n      else if (type === 'propertychange') {\n        if (event.propertyName === 'checked')\n          sendEvent('oncellchange', curNode);\n      } else if (type === 'submit') {\n        sendEvent('ondatasetcomplete', curNode);\n      }\n    }\n    // ignore non-simulated events of types we simulate\n    if ((type === 'focus' || event.type === 'blur'\n         || event.type === 'change' ||\n         event.type === 'submit') && ! event.synthetic) {\n      if (event.type === 'submit')\n        event.returnValue = false; // block all native submits, we will submit\n      return;\n    }\n\n    // morph the event\n    if (type === 'cellchange' && event.synthetic) {\n      type = event.type = 'change';\n    }\n    if (type === 'datasetcomplete' && event.synthetic) {\n      type = event.type = 'submit';\n    }\n\n    self.deliver(event);\n  }\n\n});\n"]}