{"version":3,"file":"/packages/spark.js","sources":["spark/spark.js","spark/patch.js","spark/convenience.js","spark/utils.js"],"names":[],"mappings":";;;;;;;;AAAA,oE;AACA,+D;;AAEA,4D;AACA,sD;;AAEA,oE;AACA,6C;;AAEA,qE;AACA,gC;;AAEA,iE;AACA,sE;AACA,0B;;AAEA,gE;;AAEA,mE;AACA,qE;AACA,sD;;AAEA,uE;AACA,gE;AACA,qE;AACA,gC;;AAEA,W;AACA,e;;AAEA,oC;AACA,qB;AACA,U;AACA,sB;AACA,qB;AACA,M;AACA,mC;AACA,6B;AACA,kB;AACA,4B;AACA,qC;AACA,K;AACA,I;AACA,K;;AAEA,8B;AACA,oB;;AAEA,oE;AACA,kE;AACA,oE;AACA,iE;AACA,+B;AACA,iB;;AAEA,qD;AACA,iC;AACA,6B;AACA,mC;AACA,iC;AACA,+B;AACA,+B;AACA,qC;AACA,6B;AACA,kC;AACA,oE;;AAEA,uE;AACA,8B;AACA,mD;AACA,4B;AACA,E;;AAEA,iD;AACA,yB;AACA,uD;AACA,oC;AACA,E;;;AAGA,oD;AACA,oD;AACA,oB;AACA,e;AACA,E;;AAEA,6C;AACA,6C;AACA,sC;AACA,+B;;AAEA,e;AACA,E;;AAEA,+C;AACA,M;AACA,+B;AACA,yC;;AAEA,e;AACA,E;;AAEA,4C;AACA,uE;AACA,4D;AACA,uC;AACA,oB;AACA,sB;AACA,E;;AAEA,6B;AACA,sE;AACA,qE;AACA,qE;AACA,4C;AACA,oE;AACA,2C;AACA,sC;AACA,kC;AACA,0B;AACA,wB;AACA,0C;AACA,E;;AAEA,wB;AACA,sE;AACA,sD;AACA,wB;;AAEA,iE;AACA,gE;AACA,8D;AACA,+D;AACA,4C;AACA,6C;AACA,gE;AACA,uC;AACA,yB;;AAEA,4D;AACA,qE;AACA,4C;;AAEA,uD;AACA,2B;;AAEA,yD;AACA,uC;AACA,E;;AAEA,8B;AACA,sE;AACA,qE;AACA,wD;AACA,kE;AACA,qE;AACA,+C;AACA,yC;AACA,qC;AACA,yB;AACA,+B;AACA,kB;AACA,mC;AACA,Q;AACA,K;AACA,mE;AACA,wE;AACA,yE;AACA,8D;AACA,0E;AACA,mE;AACA,2C;AACA,8C;AACA,kD;AACA,kC;AACA,mE;AACA,iC;AACA,4D;AACA,mB;AACA,e;AACA,O;AACA,8C;AACA,kB;AACA,M;;AAEA,qD;AACA,I;;AAEA,8D;AACA,gE;AACA,uD;AACA,8D;AACA,gE;AACA,yB;AACA,8B;AACA,oC;AACA,Y;AACA,mC;AACA,0C;AACA,8B;AACA,gD;AACA,Q;AACA,6B;AACA,oB;AACA,Q;AACA,6B;AACA,0C;AACA,mB;AACA,Q;AACA,iE;AACA,4D;AACA,oD;AACA,+D;AACA,6B;AACA,6B;AACA,sC;AACA,wC;AACA,iB;AACA,gC;AACA,O;AACA,M;AACA,I;;AAEA,qE;AACA,oC;AACA,oC;AACA,oB;;AAEA,yD;AACA,oE;;AAEA,sB;AACA,kD;AACA,mC;AACA,iB;AACA,iC;AACA,0C;AACA,2C;AACA,+B;AACA,+B;AACA,4E;AACA,8C;AACA,gE;AACA,4B;AACA,0D;AACA,kE;AACA,+C;AACA,W;AACA,iD;AACA,+B;AACA,S;AACA,iB;AACA,O;AACA,M;;AAEA,2B;AACA,qB;AACA,Y;;AAEA,6C;AACA,wB;AACA,c;AACA,wC;AACA,8B;AACA,wB;AACA,gD;AACA,qC;AACA,wE;AACA,2C;AACA,+D;AACA,oC;AACA,2D;AACA,0B;AACA,yB;AACA,6B;AACA,c;AACA,sC;AACA,6B;AACA,uE;AACA,uE;AACA,gC;AACA,4E;AACA,mD;AACA,8B;AACA,4D;AACA,wD;AACA,qD;AACA,+B;AACA,uE;AACA,kE;AACA,mE;AACA,0E;AACA,uE;AACA,iD;AACA,qB;AACA,gB;AACA,S;AACA,4B;AACA,sE;AACA,O;AACA,K;;AAEA,oD;AACA,6B;;AAEA,uD;AACA,yB;AACA,4E;AACA,yB;AACA,O;AACA,0B;;AAEA,8E;AACA,2E;AACA,6D;AACA,M;AACA,8E;AACA,8E;AACA,0B;AACA,M;AACA,mE;AACA,gF;AACA,0E;AACA,O;AACA,4E;AACA,4B;AACA,4D;AACA,O;;AAEA,e;AACA,G;;AAEA,G;;AAEA,2D;AACA,yD;AACA,wD;AACA,yD;AACA,iC;AACA,qC;AACA,yC;AACA,oC;AACA,kB;AACA,wB;AACA,wB;AACA,+B;AACA,I;AACA,E;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,mE;AACA,oE;AACA,6B;AACA,E;AACA,yE;AACA,iD;AACA,E;AACA,qE;AACA,sE;AACA,uD;AACA,6D;AACA,+C;AACA,wB;AACA,wC;AACA,qB;AACA,I;;AAEA,+B;AACA,kB;AACA,a;;AAEA,4D;AACA,iE;AACA,oE;AACA,mE;AACA,qE;AACA,sE;AACA,iE;AACA,kE;AACA,mC;AACA,2C;AACA,6B;AACA,+B;AACA,6B;AACA,oE;AACA,sD;AACA,iE;AACA,6D;AACA,c;AACA,6B;AACA,e;AACA,O;AACA,K;;AAEA,6D;AACA,kD;AACA,qD;AACA,8C;AACA,4D;AACA,O;;AAEA,iE;AACA,sB;AACA,M;AACA,oE;AACA,qE;AACA,kB;AACA,M;AACA,sE;AACA,6B;AACA,6B;AACA,gE;AACA,wC;;AAEA,gE;AACA,iE;AACA,kE;AACA,wC;AACA,wE;AACA,4B;AACA,K;AACA,E;;AAEA,oC;AACA,8B;AACA,4C;AACA,c;AACA,E;;;AAGA,gE;AACA,qE;AACA,e;AACA,E;AACA,oB;AACA,yC;AACA,E;AACA,iC;AACA,qD;AACA,4B;AACA,E;AACA,qE;AACA,oE;AACA,uE;AACA,2E;AACA,0C;AACA,kE;AACA,gC;AACA,E;;AAEA,4C;AACA,0E;AACA,wE;AACA,+D;AACA,oE;AACA,oB;AACA,kE;AACA,+D;AACA,I;;AAEA,0C;AACA,oB;AACA,mC;AACA,qB;AACA,4D;AACA,kB;AACA,O;AACA,I;;AAEA,4D;AACA,oB;AACA,0D;;AAEA,wF;AACA,uD;AACA,0C;AACA,wE;;AAEA,kC;AACA,mC;AACA,gC;AACA,S;AACA,M;;AAEA,8D;AACA,wC;AACA,iC;AACA,8D;AACA,6C;AACA,0B;AACA,8D;AACA,+B;AACA,uD;AACA,a;AACA,S;AACA,O;;AAEA,mE;AACA,2D;AACA,M;AACA,8E;AACA,yE;AACA,8E;AACA,6E;AACA,wC;AACA,kF;AACA,wD;AACA,wD;AACA,8D;AACA,6E;AACA,wD;AACA,6C;;AAEA,wC;AACA,8D;AACA,kG;AACA,6D;AACA,sB;AACA,qE;AACA,0D;AACA,W;AACA,W;AACA,S;AACA,O;;AAEA,iE;AACA,uD;AACA,+C;AACA,2B;AACA,6C;AACA,wB;;AAEA,yB;AACA,G;AACA,G;;;AAGA,gB;AACA,iC;AACA,mB;AACA,qD;AACA,0B;AACA,2B;AACA,E;;AAEA,mE;AACA,sE;AACA,E;AACA,kD;AACA,4D;AACA,mB;AACA,I;AACA,uE;AACA,sE;AACA,sE;AACA,yD;AACA,gE;AACA,c;AACA,oC;AACA,4C;AACA,W;;AAEA,gC;;AAEA,oE;AACA,iE;AACA,oE;AACA,sE;AACA,+D;AACA,sD;AACA,yC;;AAEA,uC;AACA,wC;AACA,oB;AACA,mC;AACA,Y;AACA,2B;AACA,6D;AACA,kC;AACA,O;AACA,O;AACA,I;;AAEA,+D;AACA,gE;AACA,wC;AACA,K;;AAEA,gF;AACA,4E;AACA,8E;AACA,+E;AACA,0E;AACA,uC;AACA,+C;AACA,yC;AACA,kC;AACA,4C;AACA,K;;AAEA,4C;;AAEA,iE;;AAEA,2C;;AAEA,8D;AACA,sB;AACA,uB;AACA,wB;AACA,gD;AACA,gC;AACA,mC;AACA,mE;;AAEA,0C;AACA,uD;AACA,O;AACA,O;;AAEA,mE;AACA,mB;AACA,mB;AACA,sC;AACA,sC;AACA,iE;AACA,8D;AACA,0B;AACA,sE;AACA,wC;AACA,Y;;AAEA,gD;AACA,wE;AACA,G;;AAEA,gD;;AAEA,qE;AACA,gE;;AAEA,sB;;AAEA,mB;;AAEA,iC;AACA,8B;AACA,yC;AACA,6D;AACA,6D;AACA,8B;AACA,iC;AACA,0D;AACA,qD;AACA,O;AACA,K;;AAEA,gE;AACA,4D;AACA,uD;AACA,oE;AACA,iE;AACA,mB;AACA,6C;AACA,K;AACA,E;;AAEA,qE;AACA,sE;AACA,wD;AACA,E;AACA,wC;AACA,2E;AACA,8D;AACA,iC;AACA,iD;AACA,4B;AACA,iB;AACA,e;AACA,G;AACA,+C;AACA,2C;AACA,kD;AACA,K;AACA,wC;AACA,E;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,6E;AACA,4B;AACA,kD;AACA,G;;AAEA,wC;AACA,qD;AACA,6B;AACA,E;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,6B;AACA,+B;AACA,yB;AACA,qE;AACA,mE;AACA,sE;AACA,yD;AACA,gE;AACA,qE;AACA,sE;AACA,uC;;AAEA,2B;AACA,4B;AACA,e;;AAEA,sB;AACA,mD;AACA,sD;AACA,oB;AACA,0B;AACA,yD;AACA,O;AACA,mC;AACA,yB;AACA,S;AACA,0B;;AAEA,2B;AACA,E;;AAEA,wE;AACA,+B;;AAEA,6D;AACA,6E;AACA,qD;AACA,4B;AACA,8C;AACA,0C;AACA,gC;AACA,K;AACA,qC;AACA,sE;AACA,uC;AACA,sC;AACA,6B;AACA,e;;AAEA,+B;AACA,qC;;AAEA,gD;AACA,4C;AACA,wE;AACA,S;AACA,O;AACA,K;;AAEA,sC;;AAEA,0C;AACA,qC;AACA,oC;AACA,mD;AACA,2B;AACA,4B;AACA,sC;AACA,O;AACA,I;;AAEA,4B;AACA,6B;AACA,2B;AACA,8B;AACA,O;AACA,O;;AAEA,wB;;AAEA,4B;AACA,+C;AACA,kB;AACA,e;;AAEA,uC;AACA,4B;AACA,S;AACA,6B;;AAEA,oC;AACA,yB;AACA,Q;;AAEA,wC;AACA,oD;;AAEA,mD;AACA,iE;AACA,mB;;AAEA,oC;AACA,0C;AACA,0C;;AAEA,yB;AACA,kD;AACA,mE;AACA,qD;AACA,uB;AACA,a;AACA,kB;AACA,0D;AACA,qD;AACA,uB;AACA,W;;AAEA,+C;AACA,0E;AACA,6B;AACA,6D;AACA,mE;;AAEA,qE;AACA,mE;AACA,wE;AACA,yE;AACA,sE;;AAEA,sE;AACA,8C;AACA,sC;AACA,6C;AACA,mC;AACA,W;AACA,S;AACA,Q;AACA,O;;AAEA,c;AACA,G;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,qC;AACA,uC;AACA,gB;AACA,sB;;AAEA,Y;AACA,sB;AACA,c;AACA,kC;AACA,mB;AACA,kC;AACA,uC;AACA,sB;AACA,oB;AACA,qD;AACA,0B;AACA,kB;AACA,sB;AACA,0C;AACA,qE;AACA,iE;AACA,8B;AACA,4B;AACA,c;AACA,W;AACA,W;AACA,uB;AACA,Y;AACA,2C;AACA,K;AACA,K;;AAEA,iB;AACA,E;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,6D;AACA,iD;AACA,8C;AACA,4B;AACA,sB;AACA,Q;AACA,uB;AACA,K;AACA,E;;;AAGA,gF;AACA,wE;AACA,qB;AACA,uC;AACA,+B;AACA,kD;AACA,iC;;AAEA,oD;AACA,oD;;AAEA,oE;AACA,0B;AACA,qB;AACA,6B;AACA,gF;AACA,2C;AACA,oD;AACA,M;AACA,K;;AAEA,4C;;AAEA,8C;AACA,uB;AACA,8C;AACA,kC;AACA,mB;AACA,4C;AACA,0C;AACA,K;AACA,K;AACA,wD;;AAEA,6B;AACA,uC;AACA,gC;AACA,6C;AACA,qC;;AAEA,kE;AACA,wE;AACA,a;AACA,I;AACA,qE;AACA,wE;AACA,uE;AACA,4C;AACA,uC;AACA,qD;AACA,qD;AACA,e;AACA,I;;AAEA,iE;AACA,qE;AACA,mB;AACA,gB;AACA,iB;AACA,uB;AACA,sB;AACA,Q;AACA,qC;AACA,8B;AACA,4C;AACA,+B;AACA,4B;AACA,kC;AACA,a;AACA,O;AACA,G;AACA,sB;AACA,6B;AACA,kB;AACA,mB;AACA,I;AACA,gE;AACA,kB;AACA,qE;AACA,e;AACA,gB;AACA,Y;AACA,yB;AACA,oC;AACA,K;AACA,K;;AAEA,qE;AACA,+B;AACA,iB;AACA,c;;AAEA,0E;AACA,sB;AACA,wE;AACA,sE;AACA,qE;AACA,0E;AACA,2C;AACA,0B;AACA,gE;AACA,wC;AACA,I;;AAEA,4B;AACA,iC;AACA,oB;AACA,0B;AACA,O;AACA,I;;AAEA,8B;AACA,uB;AACA,gD;AACA,yB;AACA,sC;AACA,qB;AACA,6E;AACA,4E;AACA,0D;;AAEA,+B;AACA,2D;AACA,qC;AACA,2D;AACA,gB;AACA,4D;AACA,S;AACA,qE;AACA,S;AACA,M;;AAEA,4B;AACA,yB;AACA,mD;AACA,4C;AACA,8E;AACA,2D;AACA,c;AACA,+D;;AAEA,4B;;AAEA,gC;AACA,S;AACA,M;;AAEA,wC;AACA,yB;AACA,wD;AACA,8B;AACA,2D;AACA,gB;AACA,4D;AACA,S;AACA,wC;AACA,gC;AACA,S;AACA,M;;AAEA,oC;AACA,yB;AACA,mC;AACA,iB;AACA,2D;AACA,sC;AACA,0C;AACA,6E;AACA,S;AACA,K;AACA,K;;AAEA,c;AACA,E;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,uB;;AAEA,8B;AACA,6B;AACA,sD;AACA,E;;AAEA,oC;AACA,0B;AACA,mC;AACA,I;AACA,yB;AACA,kC;AACA,I;AACA,6B;AACA,wB;AACA,4D;AACA,6D;AACA,I;AACA,gC;AACA,wB;AACA,+D;AACA,gE;AACA,I;AACA,uB;AACA,0B;AACA,G;AACA,G;;AAEA,sC;;AAEA,0B;AACA,qE;AACA,2B;AACA,E;AACA,gD;AACA,uC;AACA,mC;AACA,sB;;AAEA,mC;AACA,wB;;AAEA,0C;AACA,wB;AACA,4D;AACA,oC;;AAEA,iB;AACA,uE;AACA,uE;AACA,6B;AACA,gB;;AAEA,2B;AACA,8C;;AAEA,kE;AACA,gE;AACA,qE;AACA,qE;AACA,oE;AACA,mE;AACA,mE;AACA,kE;AACA,qE;AACA,mE;AACA,qE;AACA,Y;AACA,E;;AAEA,qD;AACA,uC;AACA,mB;AACA,wD;AACA,sC;AACA,sD;AACA,kC;AACA,0D;AACA,gB;AACA,G;;AAEA,2B;AACA,oB;AACA,kC;AACA,kD;AACA,gC;AACA,O;AACA,M;AACA,sC;AACA,gC;AACA,iD;AACA,wD;;AAEA,0C;AACA,gD;AACA,e;AACA,4B;AACA,uC;AACA,qE;AACA,+E;AACA,gE;AACA,U;AACA,kC;AACA,0B;AACA,uE;AACA,oC;AACA,uC;AACA,S;AACA,K;AACA,G;AACA,4B;;AAEA,gC;AACA,2B;AACA,iD;AACA,oB;AACA,8B;AACA,8D;AACA,e;AACA,O;;AAEA,uB;AACA,2B;AACA,sC;AACA,qD;AACA,uD;AACA,2B;AACA,+B;AACA,kC;AACA,wC;AACA,+C;AACA,W;AACA,S;AACA,S;;AAEA,8B;AACA,0C;AACA,mE;AACA,qE;AACA,sE;AACA,8D;AACA,oE;AACA,6D;AACA,mE;AACA,Q;AACA,qE;AACA,0D;AACA,kE;AACA,qE;AACA,qE;AACA,2D;AACA,sB;AACA,O;AACA,E;;AAEA,kD;AACA,yD;AACA,uC;AACA,E;;;;;;;;;;;;;;;;;;;AC3tCA,0E;AACA,2B;;AAEA,iC;AACA,uC;AACA,I;;AAEA,4B;AACA,+C;;;AAGA,0D;AACA,gE;AACA,yB;AACA,4B;AACA,4C;AACA,wC;AACA,K;AACA,I;;AAEA,4E;AACA,4B;AACA,8D;AACA,6B;AACA,0D;AACA,gE;;AAEA,0B;;AAEA,mD;AACA,wD;AACA,2E;AACA,kE;AACA,oD;AACA,mD;AACA,wD;AACA,mE;AACA,8C;AACA,yC;AACA,+C;AACA,O;;AAEA,e;AACA,sE;AACA,2B;AACA,gE;AACA,qC;AACA,mD;AACA,sE;AACA,8C;AACA,2E;AACA,6E;AACA,2E;AACA,0D;AACA,sC;AACA,2D;AACA,oD;AACA,W;AACA,0C;AACA,kD;AACA,8B;AACA,+B;AACA,mD;AACA,6E;AACA,2E;AACA,gF;AACA,0E;AACA,qC;AACA,2D;AACA,e;AACA,a;AACA,2D;AACA,W;AACA,S;AACA,O;AACA,K;AACA,gB;AACA,K;;AAEA,mB;;AAEA,iB;AACA,E;;;AAGA,uE;AACA,oE;AACA,E;AACA,0E;AACA,kE;AACA,kE;AACA,uE;AACA,iD;AACA,E;AACA,oE;AACA,Y;AACA,E;AACA,uE;AACA,sE;AACA,uE;AACA,mE;AACA,2E;AACA,0E;AACA,kB;AACA,E;AACA,e;AACA,+D;AACA,6B;AACA,6B;;AAEA,6B;AACA,2B;;AAEA,8B;AACA,8B;AACA,E;;;AAGA,kE;AACA,mE;AACA,mE;AACA,iE;AACA,uE;AACA,oE;AACA,qE;AACA,iE;AACA,kD;AACA,E;AACA,iE;AACA,8D;AACA,+D;AACA,iE;AACA,oD;AACA,E;AACA,+D;AACA,uE;AACA,oE;AACA,oE;AACA,qE;AACA,kE;AACA,mC;AACA,E;AACA,8D;AACA,mE;AACA,iE;AACA,gE;AACA,2D;AACA,6D;AACA,gE;AACA,8D;AACA,iE;AACA,oE;AACA,c;AACA,E;AACA,+D;AACA,mE;AACA,kE;AACA,yD;AACA,E;AACA,8D;AACA,kE;AACA,iC;AACA,mC;AACA,gD;;AAEA,2D;AACA,yC;AACA,yC;AACA,8C;AACA,oB;AACA,oB;;AAEA,2B;AACA,6C;AACA,G;;AAEA,+B;AACA,wB;;AAEA,mB;AACA,oD;AACA,uE;AACA,kE;AACA,iB;AACA,uD;AACA,8E;AACA,wD;AACA,yD;AACA,+C;AACA,+D;AACA,2C;AACA,2C;AACA,K;;AAEA,qE;AACA,uC;AACA,uC;;AAEA,yD;AACA,yD;AACA,gE;AACA,0D;AACA,+D;AACA,iE;AACA,gE;AACA,kE;AACA,2D;AACA,2D;AACA,+D;AACA,gB;AACA,sB;AACA,sD;AACA,wD;AACA,sE;AACA,mB;AACA,K;AACA,G;;AAEA,kB;AACA,4D;AACA,uD;AACA,U;AACA,sE;AACA,wB;AACA,wC;AACA,qB;AACA,K;;AAEA,gE;AACA,2B;AACA,+C;AACA,mE;AACA,6C;AACA,qE;AACA,0D;AACA,oC;AACA,8C;AACA,K;AACA,qE;AACA,iE;AACA,K;;AAEA,yB;AACA,6D;AACA,kB;AACA,yC;AACA,6C;AACA,4C;AACA,yB;AACA,iC;AACA,O;;AAEA,wB;;AAEA,8D;AACA,+B;AACA,2E;AACA,+D;AACA,c;AACA,c;AACA,iD;AACA,kD;AACA,6B;AACA,6B;AACA,O;AACA,K;AACA,G;;AAEA,iC;AACA,iC;;AAEA,c;AACA,E;;AAEA,sE;AACA,uC;AACA,uD;AACA,qC;AACA,qC;;AAEA,2D;AACA,iB;;AAEA,2D;AACA,iB;;AAEA,6B;AACA,6B;;AAEA,c;AACA,E;;AAEA,+C;AACA,E;AACA,4D;AACA,kB;AACA,uC;AACA,gC;AACA,E;;AAEA,0E;AACA,6E;AACA,0E;AACA,E;AACA,8E;AACA,gF;AACA,2C;AACA,uE;AACA,C;AACA,qE;AACA,qE;;AAEA,8C;AACA,qC;AACA,4C;AACA,yC;AACA,G;AACA,qC;AACA,4C;AACA,yC;AACA,G;;;AAGA,wB;AACA,Q;AACA,uE;AACA,6B;AACA,6B;AACA,G;;AAEA,qB;AACA,Q;AACA,uE;AACA,6B;AACA,gD;AACA,G;AACA,E;;AAEA,sD;AACA,E;AACA,mE;AACA,0E;AACA,6D;AACA,kE;AACA,+D;AACA,E;AACA,gE;AACA,wE;AACA,8C;AACA,gC;AACA,gC;;AAEA,2D;AACA,uB;AACA,uD;;AAEA,gC;;AAEA,wB;AACA,2B;;AAEA,sB;AACA,0B;AACA,iC;AACA,uD;AACA,qC;;AAEA,4E;AACA,gF;AACA,wC;AACA,6C;AACA,qE;AACA,iD;AACA,qE;AACA,iD;AACA,6E;AACA,8E;AACA,mE;AACA,mD;AACA,iD;AACA,sD;AACA,yC;AACA,c;AACA,0C;AACA,2D;AACA,O;AACA,K;AACA,G;;AAEA,2C;AACA,2B;AACA,wD;AACA,yD;AACA,wD;AACA,sD;AACA,sB;AACA,yB;AACA,e;AACA,yB;AACA,yD;AACA,4D;AACA,yB;AACA,yB;AACA,e;AACA,uD;AACA,uD;AACA,qC;AACA,yC;AACA,e;AACA,8D;AACA,0D;AACA,wD;AACA,gD;AACA,mC;AACA,e;AACA,+E;AACA,yB;AACA,yB;AACA,e;AACA,0D;AACA,uB;AACA,e;;AAEA,sE;AACA,gE;AACA,wE;AACA,0E;AACA,kD;AACA,M;AACA,0E;AACA,yD;AACA,M;AACA,qE;AACA,uE;AACA,2C;AACA,oC;AACA,0B;AACA,+C;AACA,+B;AACA,2E;AACA,kC;AACA,G;;AAEA,kC;;AAEA,4B;AACA,oB;AACA,M;AACA,kD;AACA,qD;AACA,2D;AACA,4D;AACA,8D;;AAEA,sD;AACA,qD;AACA,uD;;AAEA,6B;AACA,mB;AACA,mD;;AAEA,iB;AACA,0B;;AAEA,U;AACA,wB;;AAEA,+C;AACA,kC;AACA,2B;AACA,2C;AACA,uC;AACA,8B;AACA,6D;AACA,wC;AACA,oC;AACA,sC;AACA,gD;AACA,sC;AACA,wC;AACA,sC;AACA,yD;AACA,4B;AACA,oC;AACA,qD;AACA,kC;AACA,8B;AACA,gB;AACA,e;AACA,0C;AACA,uB;AACA,4E;AACA,W;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,+C;AACA,0C;AACA,kB;AACA,+C;AACA,I;AACA,4D;AACA,4D;;AAEA,qC;AACA,sD;;AAEA,kC;AACA,4E;AACA,gF;AACA,6C;AACA,0B;AACA,sC;AACA,0B;AACA,6C;AACA,6E;AACA,4D;AACA,mD;AACA,G;;AAEA,+E;AACA,+E;AACA,sD;AACA,2E;AACA,6E;AACA,6B;AACA,I;AACA,sD;AACA,0C;AACA,I;AACA,8E;AACA,4E;AACA,2E;AACA,yE;AACA,qE;AACA,wC;AACA,I;AACA,0E;AACA,6E;AACA,yE;AACA,gF;AACA,wE;AACA,8D;AACA,yE;AACA,+E;AACA,+E;AACA,yB;AACA,qD;AACA,8D;AACA,4E;AACA,+E;AACA,iE;AACA,G;;AAEA,qC;AACA,8B;AACA,gF;AACA,c;AACA,qC;AACA,iC;;AAEA,uD;AACA,sC;AACA,qB;AACA,6C;AACA,Q;AACA,qC;AACA,G;AACA,E;;AAEA,4B;;;;;;;;;;;;;;;;;;;AC7jBA,qC;AACA,mC;AACA,yB;AACA,8D;AACA,yE;AACA,gC;AACA,S;AACA,K;AACA,E;;AAEA,2D;AACA,mC;AACA,+C;AACA,0D;AACA,mD;AACA,2D;AACA,S;AACA,oB;AACA,qD;AACA,O;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;ACrBA,wC;AACA,mB;;AAEA,0C;AACA,+B;AACA,yC;AACA,wC;AACA,qC;AACA,kD;AACA,wD;AACA,mC;AACA,oD;AACA,mD;AACA,iC;AACA,mC;AACA,0D;AACA,kB;AACA,sC;;AAEA,wD;AACA,qB;AACA,4B;AACA,4D;AACA,yB;AACA,mB;AACA,2C;AACA,gB;AACA,4C;AACA,uD;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,e;AACA,E","sourcesContent":["// XXX adjust Spark API so that the modules (eg, list, events) could\n// have been written by third parties on top of the public API?\n\n// XXX rename isolate to reflect that it is the only root of\n// deps-based reactivity ('track'? 'compute'? 'sync'?)\n\n// XXX specify flush order someday (context dependencies? is this in\n// the domain of spark -- overdraw concerns?)\n\n// XXX if not on IE6-8, don't do the extra work (traversals for event\n// setup) those browsers require\n\n// XXX flag errors if you have two landmarks with the same branch\n// path, or if you have multiple preserve nodes in a landmark with the\n// same selector and label\n\n// XXX should functions with an htmlFunc use try/finally inside?\n\n// XXX test that non-Spark.render case works for each function (eg,\n// list() returns the expected HTML, Spark.createLandmark creates and\n// then destroys a landmark -- may already be tested?)\n\n// XXX in landmark-demo, if Template.timer.created throws an exception,\n// then it is never called again, even if you push the 'create a\n// timer' button again. the problem is almost certainly in afterFlush\n// (not hard to see what it is.)\n\nSpark = {};\nSparkTest = {};\n\nvar currentRenderer = (function () {\n  var current = null;\n  return {\n    get: function () {\n      return current;\n    },\n    withValue: function (v, func) {\n      var previous = current;\n      current = v;\n      try { return func(); }\n      finally { current = previous; }\n    }\n  };\n})();\n\nTAG = \"_spark_\" + Random.id();\nSparkTest.TAG = TAG;\n\n// We also export this as Spark._TAG due to a historical accident. I\n// don't know if anything uses it (possibly some of Chris Mather's\n// stuff?)  but let's keep exporting it since without it it would be\n// very difficult for code outside the spark package to, eg, walk\n// spark's liverange hierarchy.\nSpark._TAG = TAG;\n\n// XXX document contract for each type of annotation?\nvar ANNOTATION_NOTIFY = \"notify\";\nvar ANNOTATION_DATA = \"data\";\nvar ANNOTATION_ISOLATE = \"isolate\";\nvar ANNOTATION_EVENTS = \"events\";\nvar ANNOTATION_WATCH = \"watch\";\nvar ANNOTATION_LABEL = \"label\";\nvar ANNOTATION_LANDMARK = \"landmark\";\nvar ANNOTATION_LIST = \"list\";\nvar ANNOTATION_LIST_ITEM = \"item\";\n// XXX why do we need, eg, _ANNOTATION_ISOLATE? it has no semantics?\n\n// Use from tests to turn on extra UniversalEventListener sanity checks\nvar checkIECompliance = false;\nSparkTest.setCheckIECompliance = function (value) {\n  checkIECompliance = value;\n};\n\n// Private interface to 'preserve-inputs' package\nvar globalPreserves = {};\nSpark._addGlobalPreserve = function (selector, value) {\n  globalPreserves[selector] = value;\n};\n\n\nvar makeRange = function (type, start, end, inner) {\n  var range = new LiveRange(TAG, start, end, inner);\n  range.type = type;\n  return range;\n};\n\nvar findRangeOfType = function (type, node) {\n  var range = LiveRange.findRange(TAG, node);\n  while (range && range.type !== type)\n    range = range.findParent();\n\n  return range;\n};\n\nvar findParentOfType = function (type, range) {\n  do {\n    range = range.findParent();\n  } while (range && range.type !== type);\n\n  return range;\n};\n\nvar notifyWatchers = function (start, end) {\n  var tempRange = new LiveRange(TAG, start, end, true /* innermost */);\n  for (var walk = tempRange; walk; walk = walk.findParent())\n    if (walk.type === ANNOTATION_WATCH)\n      walk.notify();\n  tempRange.destroy();\n};\n\nvar eventGuardActive = false;\n// Spark does DOM manipulation inside an event guard to prevent events\n// like \"blur\" from firing.  It would be nice to deliver these events\n// in some cases, but running fresh event handling code on an invalid\n// LiveRange tree can easily produce errors.\n// This guard was motivated by seeing errors in Todos when switching\n// windows while an input field is focused.\nvar withEventGuard = function (func) {\n  var previous = eventGuardActive;\n  eventGuardActive = true;\n  try { return func(); }\n  finally { eventGuardActive = previous; }\n};\n\nRenderer = function () {\n  // Map from annotation ID to an annotation function, which is called\n  // at render time and receives (startNode, endNode).\n  this.annotations = {};\n\n  // Map from branch path to \"notes\" object, organized as a tree.\n  // Each node in the tree has child pointers named ('_'+label).\n  // Properties that don't start with '_' are arbitrary notes.\n  // For example, the \"happiness\" of the branch path consisting\n  // of labels \"foo\" and then \"bar\" would be\n  // `this._branchNotes._foo._bar.happiness`.\n  // Access to these notes is provided by LabelStack objects, of\n  // which `this.currentBranch` is one.\n  this._branchNotes = {};\n\n  // The label stack representing the current branch path we\n  // are in (based on calls to `Spark.labelBranch(label, htmlFunc)`).\n  this.currentBranch = this.newLabelStack();\n\n  // All landmark ranges created during this rendering.\n  this.landmarkRanges = [];\n\n  // Assembles the preservation information for patching.\n  this.pc = new PreservationController;\n};\n\n_.extend(Renderer.prototype, {\n  // `what` can be a function that takes a LiveRange, or just a set of\n  // attributes to add to the liverange.  type and what are optional.\n  // if no type is passed, no liverange will be created.\n  // If what is a function, it will be called no matter what, even\n  // if the annotated HTML was not used and no LiveRange was created,\n  // in which case it gets null as an argument.\n  annotate: function (html, type, what) {\n    if (typeof what !== 'function') {\n      var attribs = what;\n      what = function (range) {\n        if (range)\n          _.extend(range, attribs);\n      };\n    }\n    // The annotation tags that we insert into HTML strings must be\n    // unguessable in order to not create potential cross-site scripting\n    // attack vectors, so we use random strings.  Even a well-written app\n    // that avoids XSS vulnerabilities might, for example, put\n    // unescaped < and > in HTML attribute values, where they are normally\n    // safe.  We can't assume that a string like '<1>' came from us\n    // and not arbitrary user-entered data.\n    var id = (type || '') + \":\" + Random.id();\n    this.annotations[id] = function (start, end) {\n      if ((! start) || (! type)) {\n        // ! start: materialize called us with no args because this\n        // annotation wasn't used\n        // ! type: no type given, don't generate a LiveRange\n        what(null);\n        return;\n      }\n      var range = makeRange(type, start, end);\n      what(range);\n    };\n\n    return \"<$\" + id + \">\" + html + \"</$\" + id + \">\";\n  },\n\n  // A LabelStack is a mutable branch path that you can modify\n  // by pushing or popping labels.  At any time, you can ask for\n  // this Renderer's notes for the current branch path.\n  // Renderer's `currentBranch` field is a LabelStack, but you\n  // can create your own for the purpose of walking the branches\n  // and accessing notes.\n  newLabelStack: function () {\n    var stack = [this._branchNotes];\n    return {\n      pushLabel: function (label) {\n        var top = stack[stack.length - 1];\n        var key = '_' + label;\n        stack.push(top[key] = (top[key] || {}));\n      },\n      popLabel: function () {\n        stack.pop();\n      },\n      getNotes: function () {\n        var top = stack[stack.length - 1];\n        return top;\n      },\n      // Mark this branch with `getNotes()[prop] = true` and also\n      // walk up the stack marking parent branches (until an\n      // existing truthy value for `prop` is found).\n      // This makes it easy to test whether any descendent of a\n      // branch has the mark.\n      mark: function (prop) {\n        for (var i = stack.length - 1;\n             i >= 0 && ! stack[i][prop];\n             i--)\n          stack[i][prop] = true;\n      }\n    };\n  },\n\n  // Turn the `html` string into a fragment, applying the annotations\n  // from 'renderer' in the process.\n  materialize: function (htmlFunc) {\n    var self = this;\n\n    var html = currentRenderer.withValue(self, htmlFunc);\n    html = self.annotate(html); // wrap with an anonymous annotation\n\n    var fragById = {};\n    var replaceInclusions = function (container) {\n      var n = container.firstChild;\n      while (n) {\n        var next = n.nextSibling;\n        if (n.nodeType === 8) { // COMMENT\n          var frag = fragById[n.nodeValue];\n          if (frag === false) {\n            // id already used!\n            throw new Error(\"Spark HTML fragments may only be used once. \" +\n                            \"Second use in \" +\n                            DomUtils.fragmentToHtml(container));\n          } else if (frag) {\n            fragById[n.nodeValue] = false; // mark as used\n            DomUtils.wrapFragmentForContainer(frag, n.parentNode);\n            n.parentNode.replaceChild(frag, n);\n          }\n        } else if (n.nodeType === 1) { // ELEMENT\n          replaceInclusions(n);\n        }\n        n = next;\n      }\n    };\n\n    var bufferStack = [[]];\n    var idStack = [];\n    var ret;\n\n    var regex = /<(\\/?)\\$([^<>]+)>|<|[^<]+/g;\n    regex.lastIndex = 0;\n    var parts;\n    while ((parts = regex.exec(html))) {\n      var isOpen = ! parts[1];\n      var id = parts[2];\n      var annotationFunc = self.annotations[id];\n      if (annotationFunc === false) {\n        throw new Error(\"Spark HTML fragments may be used only once. \" +\n                        \"Second use of: \" +\n                        DomUtils.fragmentToHtml(fragById[id]));\n      } else if (! annotationFunc) {\n        bufferStack[bufferStack.length - 1].push(parts[0]);\n      } else if (isOpen) {\n        idStack.push(id);\n        bufferStack.push([]);\n      } else {\n        var idOnStack = idStack.pop();\n        if (idOnStack !== id)\n          throw new Error(\"Range mismatch: \" + idOnStack + \" / \" + id);\n        var frag = DomUtils.htmlToFragment(bufferStack.pop().join(''));\n        replaceInclusions(frag);\n        // empty frag becomes HTML comment <!--empty--> so we have start/end\n        // nodes to pass to the annotation function\n        if (! frag.firstChild)\n          frag.appendChild(document.createComment(\"empty\"));\n        annotationFunc(frag.firstChild, frag.lastChild);\n        self.annotations[id] = false; // mark as used\n        if (! idStack.length) {\n          // we're done; we just rendered the contents of the top-level\n          // annotation that we wrapped around htmlFunc ourselves.\n          // there may be unused fragments in fragById that include\n          // LiveRanges, but only if the user broke the rules by including\n          // an annotation somewhere besides element level, like inside\n          // an attribute (which is not allowed).\n          ret = frag;\n          break;\n        }\n        fragById[id] = frag;\n        bufferStack[bufferStack.length - 1].push('<!--' + id + '-->');\n      }\n    }\n\n    scheduleOnscreenSetup(ret, self.landmarkRanges);\n    self.landmarkRanges = [];\n\n    _.each(self.annotations, function(annotationFunc) {\n      if (annotationFunc)\n        // call annotation func with no arguments to mean \"you weren't used\"\n        annotationFunc();\n    });\n    self.annotations = {};\n\n    // Save original versions of every 'value' property. We want elements that\n    // have a value *attribute*, as well as form elements that have a value\n    // property but no value attribute (textarea and select).\n    //\n    // We save it in a one-element array expando. We use the array because IE8\n    // gets confused by expando properties with scalar values and exposes them\n    // as HTML attributes.\n    //\n    // We also save the values of CHECKED for radio and checkboxes.\n    _.each(DomUtils.findAll(ret, '[value], textarea, select'), function (node) {\n      node._sparkOriginalRenderedValue = [DomUtils.getElementValue(node)];\n    });\n    _.each(DomUtils.findAll(ret, 'input[type=checkbox], input[type=radio]'),\n           function (node) {\n      node._sparkOriginalRenderedChecked = [!!node.checked];\n    });\n\n    return ret;\n  }\n\n});\n\n// Decorator for Spark annotations that take `html` and are\n// pass-through without a renderer.  With this decorator,\n// the annotation routine gets the current renderer, and\n// if there isn't one returns `html` (the last argument).\nvar withRenderer = function (f) {\n  return function (/* arguments */) {\n    var renderer = currentRenderer.get();\n    var args = _.toArray(arguments);\n    if (!renderer)\n      return args.pop();\n    args.push(renderer);\n    return f.apply(null, args);\n  };\n};\n\n/******************************************************************************/\n/* Render and finalize                                                        */\n/******************************************************************************/\n\n// Schedule setup tasks to run at the next flush, which is when the\n// newly rendered fragment must be on the screen (if it doesn't want\n// to get garbage-collected.)\n//\n// 'landmarkRanges' is a list of the landmark ranges in 'frag'. It may be\n// omitted if frag doesn't contain any landmarks.\n//\n// XXX expose in the public API, eg as Spark.introduce(), so the user\n// can call it when manually inserting nodes? (via, eg, jQuery?) -- of\n// course in that case 'landmarkRanges' would be empty.\nvar scheduleOnscreenSetup = function (frag, landmarkRanges) {\n  var renderedRange = new LiveRange(TAG, frag);\n  var finalized = false;\n  renderedRange.finalize = function () {\n    finalized = true;\n  };\n\n  Deps.afterFlush(function () {\n    if (finalized)\n      return;\n\n    if (!DomUtils.isInDocument(renderedRange.firstNode())) {\n      // We've detected that some nodes were taken off the screen\n      // without calling Spark.finalize(). This could be because the\n      // user rendered them, but didn't insert them in the document\n      // before the next flush(). Or it could be because they used to\n      // be onscreen, but they were manually taken offscreen (eg, with\n      // jQuery) and the user neglected to call finalize() on the\n      // removed nodes. Help the user out by finalizing the entire\n      // subtree that is offscreen.\n      var node = renderedRange.firstNode();\n      while (node.parentNode)\n        node = node.parentNode;\n      if (node[\"_protect\"]) {\n        // test code can use this property to mark a root-level node\n        // (such as a DocumentFragment) as immune from\n        // autofinalization. effectively, the DocumentFragment is\n        // considered to be a first-class peer of `document`.\n      } else {\n        Spark.finalize(node);\n        return;\n      }\n    }\n\n    // Deliver render callbacks to all landmarks that are now\n    // onscreen (possibly not for the first time.)\n    _.each(landmarkRanges, function (landmarkRange) {\n      if (! landmarkRange.isPreservedConstant)\n        landmarkRange.rendered.call(landmarkRange.landmark);\n    });\n\n    // Deliver render callbacks to all landmarks that enclose the\n    // updated region.\n    //\n    // XXX unify with notifyWatchers. maybe remove _ANNOTATION_WATCH\n    // and just give everyone a contentsModified callback (sibling to\n    // 'finalize')\n    //\n    // future: include an argument in the callback to distinguish this\n    // case from the previous\n    var walk = renderedRange;\n    while ((walk = findParentOfType(ANNOTATION_LANDMARK, walk)))\n      walk.rendered.call(walk.landmark);\n\n    // This code can run several times on the same nodes (if the\n    // output of a render is included in a render), so it must be\n    // idempotent. This is not the best, asymptotically. There are\n    // things we could do to improve it.\n    notifyWatchers(renderedRange.firstNode(), renderedRange.lastNode());\n    renderedRange.destroy();\n  });\n};\n\nSpark.render = function (htmlFunc) {\n  var renderer = new Renderer;\n  var frag = renderer.materialize(htmlFunc);\n  return frag;\n};\n\n\n// Find all of all nodes and regions that should be preserved in\n// patching. Return a list of objects. There are two kinds of objects\n// in the list:\n//\n// A preserved node:\n//   {type: \"node\", from: Node, to: Node}\n//\n// A preserved (constant) region:\n//   {type: \"region\", fromStart: Node, fromEnd: Node,\n//      newRange: LiveRange}\n//\n// `existingRange` is the range in the document whose contents are to\n// be replaced. `newRange` holds the new contents and is not part of\n// the document DOM tree.  The implementation will temporarily reparent\n// the nodes in `newRange` into the document to check for selector matches.\nvar PreservationController = function () {\n  this.roots = []; // keys 'landmarkRange', 'fromRange', 'toRange'\n  this.regionPreservations = [];\n};\n\n_.extend(PreservationController.prototype, {\n  // Specify preservations that should be in effect on a fromRange/toRange\n  // pair.  If specified, `optContextNode` should be an ancestor node of\n  // fromRange that selectors are to be considered relative to.\n  addRoot: function (preserve, fromRange, toRange, optContextNode) {\n    var self = this;\n    self.roots.push({ context: optContextNode, preserve: preserve,\n                      fromRange: fromRange, toRange: toRange});\n  },\n\n  addConstantRegion: function (from, to) {\n    var self = this;\n    self.regionPreservations.push({\n      type: \"region\",\n      fromStart: from.firstNode(), fromEnd: from.lastNode(),\n      newRange: to\n    });\n  },\n\n  computePreservations: function (existingRange, newRange) {\n    var self = this;\n    var preservations = _.clone(self.regionPreservations);\n\n    var visitLabeledNodes = function (context, clipRange, nodeLabeler, selector, func) {\n      context = (context || clipRange.containerNode());\n      var nodes = DomUtils.findAllClipped(\n        context, selector, clipRange.firstNode(), clipRange.lastNode());\n\n      _.each(nodes, function (n) {\n        var label = nodeLabeler(n);\n        label && func(n, label);\n      });\n    };\n\n    // Find the old incarnation of each of the preserved nodes\n    _.each(self.roots, function (root) {\n      root.fromNodesByLabel = {};\n      _.each(root.preserve, function (nodeLabeler, selector) {\n        root.fromNodesByLabel[selector] = {};\n        visitLabeledNodes(\n          root.context, root.fromRange, nodeLabeler, selector,\n          function (n, label) {\n            root.fromNodesByLabel[selector][label] = n;\n          });\n      });\n    });\n\n    // Temporarily put newRange into the document so that we can do\n    // properly contextualized selector queries against it.\n    //\n    // Create a temporary range around newRange, and also around any enclosing\n    // ranges that happen to also start and end on those nodes.  It is ok\n    // to temporarily put these in the document as well, because CSS selectors\n    // don't care and we will put them back.  `tempRange` will hold our place\n    // in the tree `newRange` came from.\n    var tempRange = new LiveRange(TAG, newRange.firstNode(), newRange.lastNode());\n    var commentFrag = document.createDocumentFragment();\n    commentFrag.appendChild(document.createComment(\"\"));\n    var newRangeFrag = tempRange.replaceContents(commentFrag);\n    // `wrapperRange` will mark where we inserted newRange into the document.\n    var wrapperRange = new LiveRange(TAG, newRangeFrag);\n    existingRange.insertBefore(newRangeFrag);\n\n    _.each(self.roots, function (root) {\n      _.each(root.preserve, function (nodeLabeler, selector) {\n        visitLabeledNodes(root.context, root.toRange, nodeLabeler, selector, function (n, label) {\n          var match = root.fromNodesByLabel[selector][label];\n          if (match) {\n            preservations.push({ type: \"node\", from: match, to: n });\n            root.fromNodesByLabel[selector][label] = null;\n          }\n        });\n      });\n    });\n\n    // Extraction is legal because we're just taking the document\n    // back to the state it was in before insertBefore.\n    var extractedFrag = wrapperRange.extract();\n    wrapperRange.destroy();\n    tempRange.replaceContents(extractedFrag);\n    tempRange.destroy();\n\n    return preservations;\n  }\n});\n\n\n// XXX debugging\nvar pathForRange = function (r) {\n  var path = [], r;\n  while ((r = findParentOfType(ANNOTATION_LABEL, r)))\n    path.unshift(r.label);\n  return path.join(' :: ');\n};\n\n// `range` is a region of `document`. Modify it in-place so that it\n// matches the result of Spark.render(htmlFunc), preserving landmarks.\n//\nSpark.renderToRange = function (range, htmlFunc) {\n  // `range` may be out-of-document and we don't check here.\n  // XXX should we?\n  //\n  // Explicit finalization of ranges (done within Spark or by a call to\n  // Spark.finalize) prevents us from being called in the first place.\n  // The newly rendered material will be checked to see if it's in the\n  // document by scheduleOnscreenSetUp's scheduled setup.\n  // However, if range is not valid, bail out now before running\n  // htmlFunc.\n  var startNode = range.firstNode();\n  if (! startNode || ! startNode.parentNode)\n    return;\n\n  var renderer = new Renderer();\n\n  // Call 'func' for each landmark in 'range'. Pass two arguments to\n  // 'func', the range, and an extra \"notes\" object such that two\n  // landmarks receive the same (===) notes object iff they have the\n  // same branch path. 'func' can write to the notes object so long as\n  // it limits itself to attributes that do not start with '_'.\n  var visitLandmarksInRange = function (range, func) {\n    var stack = renderer.newLabelStack();\n\n    range.visit(function (isStart, r) {\n      if (r.type === ANNOTATION_LABEL) {\n        if (isStart)\n          stack.pushLabel(r.label);\n        else\n          stack.popLabel();\n      } else if (r.type === ANNOTATION_LANDMARK && isStart) {\n        func(r, stack.getNotes());\n      }\n    });\n  };\n\n  // Find all of the landmarks in the old contents of the range\n  visitLandmarksInRange(range, function (landmarkRange, notes) {\n    notes.originalRange = landmarkRange;\n  });\n\n  // Once we render the new fragment, as soon as it is placed into the DOM (even\n  // temporarily), if any radio buttons in the new framgent are checked, any\n  // radio buttons with the same name in the entire document will be unchecked\n  // (since only one radio button of a given name can be checked at a time). So\n  // we save the current checked value of all radio buttons in an expando.\n  var radios = DomUtils.findAllClipped(\n    range.containerNode(), 'input[type=radio]',\n    range.firstNode(), range.lastNode());\n  _.each(radios, function (node) {\n    node._currentChecked = [!!node.checked];\n  });\n\n  var frag = renderer.materialize(htmlFunc);\n\n  DomUtils.wrapFragmentForContainer(frag, range.containerNode());\n\n  var tempRange = new LiveRange(TAG, frag);\n\n  // find preservation roots from matched landmarks inside the\n  // rerendered region\n  var pc = renderer.pc;\n  visitLandmarksInRange(\n    tempRange, function (landmarkRange, notes) {\n      if (notes.originalRange) {\n        if (landmarkRange.constant)\n          pc.addConstantRegion(notes.originalRange, landmarkRange);\n\n        pc.addRoot(landmarkRange.preserve,\n                   notes.originalRange, landmarkRange);\n      }\n    });\n\n  // find preservation roots that come from landmarks enclosing the\n  // updated region\n  var walk = range;\n  while ((walk = walk.findParent())) {\n    if (! walk.firstNode().parentNode)\n      // we're in a DOM island with a top-level range (not really\n      // allowed, but could happen if `range` is on nodes that\n      // manually removed.\n      // XXX check for this sooner; hard to reason about this function\n      // on a \"malformed\" liverange tree\n      break;\n\n    if (walk.type === ANNOTATION_LANDMARK, walk)\n      pc.addRoot(walk.preserve, range, tempRange, walk.containerNode());\n  }\n\n  pc.addRoot(globalPreserves, range, tempRange);\n\n  // compute preservations (must do this before destroying tempRange)\n  var preservations = pc.computePreservations(range, tempRange);\n\n  tempRange.destroy();\n\n  var results = {};\n\n  // Patch! (using preservations)\n  withEventGuard(function () {\n    range.operate(function (start, end) {\n      // XXX this will destroy all liveranges, including ones\n      // inside constant regions whose DOM nodes we are going\n      // to preserve untouched\n      Spark.finalize(start, end);\n      patch(start.parentNode, frag, start.previousSibling,\n            end.nextSibling, preservations, results);\n    });\n  });\n\n  _.each(results.regionPreservations, function (landmarkRange) {\n    // Rely on the fact that computePreservations only emits\n    // region preservations whose ranges are landmarks.\n    // This flag means that landmarkRange is a new constant landmark\n    // range that matched an old one *and* was DOM-preservable by\n    // the patcher.\n    landmarkRange.isPreservedConstant = true;\n  });\n};\n\n// Delete all of the liveranges in the range of nodes between `start`\n// and `end`, and call their 'finalize' function if any. Or instead of\n// `start` and `end` you may pass a fragment in `start`.\n//\nSpark.finalize = function (start, end) {\n  if (! start.parentNode && start.nodeType !== 11 /* DocumentFragment */) {\n    // Workaround for LiveRanges' current inability to contain\n    // a node with no parentNode.\n    var frag = document.createDocumentFragment();\n    frag.appendChild(start);\n    start = frag;\n    end = null;\n  }\n  var wrapper = new LiveRange(TAG, start, end);\n  wrapper.visit(function (isStart, range) {\n    isStart && range.finalize && range.finalize();\n  });\n  wrapper.destroy(true /* recursive */);\n};\n\n/******************************************************************************/\n/* Data contexts                                                              */\n/******************************************************************************/\n\nSpark.setDataContext = withRenderer(function (dataContext, html, _renderer) {\n  return _renderer.annotate(\n    html, ANNOTATION_DATA, { data: dataContext });\n});\n\nSpark.getDataContext = function (node) {\n  var range = findRangeOfType(ANNOTATION_DATA, node);\n  return range && range.data;\n};\n\n/******************************************************************************/\n/* Events                                                                     */\n/******************************************************************************/\n\nvar universalListener = null;\nvar getListener = function () {\n  if (!universalListener)\n    universalListener = new UniversalEventListener(function (event) {\n      // Handle a currently-propagating event on a particular node.\n      // We walk each enclosing liverange of the node and offer it the\n      // chance to handle the event. It's range.handler's\n      // responsibility to check isImmediatePropagationStopped()\n      // before delivering events to the user. We precompute the list\n      // of enclosing liveranges to defend against the case where user\n      // event handlers change the DOM.\n\n      if (eventGuardActive)\n        // swallow the event\n        return;\n\n      var ranges = [];\n      var walk = findRangeOfType(ANNOTATION_EVENTS,\n                                 event.currentTarget);\n      while (walk) {\n        ranges.push(walk);\n        walk = findParentOfType(ANNOTATION_EVENTS, walk);\n      }\n      _.each(ranges, function (r) {\n        r.handler(event);\n      });\n    }, checkIECompliance);\n\n  return universalListener;\n};\n\nSpark.attachEvents = withRenderer(function (eventMap, html, _renderer) {\n  var listener = getListener();\n\n  var handlerMap = {}; // type -> [{selector, callback}, ...]\n  // iterate over eventMap, which has form {\"type selector, ...\": callbacks},\n  // callbacks can either be a fn, or an array of fns\n  // and populate handlerMap\n  _.each(eventMap, function(callbacks, spec) {\n    if ('function' === typeof callbacks) {\n      callbacks = [ callbacks ];\n    }\n    var clauses = spec.split(/,\\s+/);\n    // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\n    _.each(clauses, function (clause) {\n      var parts = clause.split(/\\s+/);\n      if (parts.length === 0)\n        return;\n\n      var type = parts.shift();\n      var selector = parts.join(' ');\n\n      handlerMap[type] = handlerMap[type] || [];\n      _.each(callbacks, function(callback) {\n        handlerMap[type].push({selector: selector, callback: callback});\n      });\n    });\n  });\n\n  var eventTypes = _.keys(handlerMap);\n\n  var installHandlers = function (range) {\n    _.each(eventTypes, function (t) {\n      for(var n = range.firstNode(),\n              after = range.lastNode().nextSibling;\n          n && n !== after;\n          n = n.nextSibling)\n        listener.installHandler(n, t);\n    });\n  };\n\n  html = _renderer.annotate(\n    html, ANNOTATION_WATCH, {\n      notify: function () {\n        installHandlers(this);\n      }\n    });\n\n  var finalized = false;\n\n  html = _renderer.annotate(\n    html, ANNOTATION_EVENTS, function (range) {\n      if (! range)\n        return;\n\n      _.each(eventTypes, function (t) {\n        listener.addType(t);\n      });\n      installHandlers(range);\n\n      range.finalize = function () {\n        finalized = true;\n      };\n\n      range.handler = function (event) {\n        var handlers = handlerMap[event.type] || [];\n\n        for (var i = 0; i < handlers.length; i++) {\n          if (finalized || event.isImmediatePropagationStopped())\n            return;\n\n          var handler = handlers[i];\n          var callback = handler.callback;\n          var selector = handler.selector;\n\n          if (selector) {\n            if (! DomUtils.matchesSelectorClipped(\n              event.currentTarget, range.containerNode(), selector,\n              range.firstNode(), range.lastNode())) {\n              continue;\n            }\n          } else {\n            // if no selector, only match the event target\n            if (event.currentTarget !== event.target)\n              continue;\n          }\n\n          // Found a matching handler. Call it.\n          var eventData = Spark.getDataContext(event.currentTarget) || {};\n          var landmarkRange =\n                findParentOfType(ANNOTATION_LANDMARK, range);\n          var landmark = (landmarkRange && landmarkRange.landmark);\n\n          // Note that the handler can do arbitrary things, like call\n          // Deps.flush() or otherwise remove and finalize parts of\n          // the DOM.  We can't assume `range` is valid past this point,\n          // and we'll check the `finalized` flag at the top of the loop.\n          var returnValue = callback.call(eventData, event, landmark);\n\n          // allow app to `return false` from event handler, just like\n          // you can in a jquery event handler\n          if (returnValue === false) {\n            event.stopImmediatePropagation();\n            event.preventDefault();\n          }\n        }\n      };\n    });\n\n  return html;\n});\n\n/******************************************************************************/\n/* Isolate                                                                    */\n/******************************************************************************/\n\nSpark.isolate = function (htmlFunc) {\n  var renderer = currentRenderer.get();\n  if (!renderer)\n    return htmlFunc();\n\n  var range;\n  var firstRun = true;\n  var retHtml;\n  Deps.autorun(function (handle) {\n    if (firstRun) {\n      retHtml = renderer.annotate(\n        htmlFunc(), ANNOTATION_ISOLATE,\n        function (r) {\n          if (! r) {\n            // annotation not used; kill this autorun\n            handle.stop();\n          } else {\n            range = r;\n            range.finalize = function () {\n              // Spark.finalize() was called on our range (presumably\n              // because it was removed from the document.)  Kill\n              // this autorun.\n              handle.stop();\n            };\n          }\n        });\n      firstRun = false;\n    } else {\n      Spark.renderToRange(range, htmlFunc);\n    }\n  });\n\n  return retHtml;\n};\n\n/******************************************************************************/\n/* Lists                                                                      */\n/******************************************************************************/\n\n// XXX duplicated code from minimongo.js.  It's small though.\nvar applyChanges = function (doc, changeFields) {\n  _.each(changeFields, function (value, key) {\n    if (value === undefined)\n      delete doc[key];\n    else\n      doc[key] = value;\n  });\n};\n\n\n// If minimongo is available (it's a weak dependency) use its ID stringifier (so\n// that, eg, ObjectId and strings don't overlap). Otherwise just use the\n// identity function.\n// This is also used in convenience.js.\nidStringify = Package.minimongo\n  ? Package.minimongo.LocalCollection._idStringify\n  : function (id) { return id; };\n\nSpark.list = function (cursor, itemFunc, elseFunc) {\n  elseFunc = elseFunc || function () { return ''; };\n\n  // Create a level of indirection around our cursor callbacks so we\n  // can change them later\n  var callbacks = {};\n  var observerCallbacks = {};\n  _.each([\"addedBefore\", \"removed\", \"movedBefore\", \"changed\"], function (name) {\n    observerCallbacks[name] = function () {\n      return callbacks[name].apply(null, arguments);\n    };\n  });\n\n  // Get the current contents of the cursor.\n\n  var itemDict = new OrderedDict(idStringify);\n  _.extend(callbacks, {\n    addedBefore: function (id, item, before) {\n      var doc = EJSON.clone(item);\n      doc._id = id;\n      var elt = {doc: doc, liveRange: null};\n      itemDict.putBefore(id, elt, before);\n    }\n  });\n  var handle = cursor.observeChanges(observerCallbacks);\n\n  // Get the renderer, if any\n  var renderer = currentRenderer.get();\n  var maybeAnnotate = renderer ?\n        _.bind(renderer.annotate, renderer) :\n    function (html) { return html; };\n\n  // Templates should have access to data and methods added by the\n  // transformer, but observeChanges doesn't transform, so we have to do\n  // it here.\n  //\n  // NOTE: this is a little bit of an abstraction violation. Ideally,\n  // the only thing Spark should know about Minimongo is the contract of\n  // observeChanges. In theory, anything that implements observeChanges\n  // could be passed to Spark.list. But meh.\n  var transformedDoc = function (doc) {\n    if (cursor.getTransform && cursor.getTransform())\n      return cursor.getTransform()(EJSON.clone(doc));\n    return doc;\n  };\n\n  // Render the initial contents. If we have a renderer, create a\n  // range around each item as well as around the list, and save them\n  // off for later.\n  var html = '';\n  var outerRange;\n  if (itemDict.empty())\n    html = elseFunc();\n  else {\n    itemDict.forEach(function (elt) {\n        html += maybeAnnotate(\n          itemFunc(transformedDoc(elt.doc)),\n          ANNOTATION_LIST_ITEM,\n          function (range) {\n            elt.liveRange = range;\n          });\n    });\n  }\n  var stopped = false;\n  var cleanup = function () {\n    handle.stop();\n    stopped = true;\n  };\n  html = maybeAnnotate(html, ANNOTATION_LIST, function (range) {\n    if (! range) {\n      // We never ended up on the screen (caller discarded our return\n      // value)\n      cleanup();\n    } else {\n      outerRange = range;\n      outerRange.finalize = cleanup;\n    }\n  });\n\n  // No renderer? Then we have no way to update the returned html and\n  // we can close the observer.\n  if (! renderer)\n    cleanup();\n\n  // Called by `removed` and `moved` in order to cause render callbacks on\n  // parent landmarks.\n  // XXX This is not the final solution.  1) This code should be unified\n  // with the code in scheduleOnscreenSetup.  2) In general, lists are\n  // going to cause a lot of callbacks (one per collection callback).\n  // Maybe that will make sense if we give render callbacks subrange info.\n  var notifyParentsRendered = function () {\n    var walk = outerRange;\n    while ((walk = findParentOfType(ANNOTATION_LANDMARK, walk)))\n      walk.rendered.call(walk.landmark);\n  };\n\n  var later = function (f) {\n    Deps.afterFlush(function () {\n      if (! stopped)\n        withEventGuard(f);\n    });\n  };\n\n  // The DOM update callbacks.\n  _.extend(callbacks, {\n    addedBefore: function (id, fields, before) {\n      later(function () {\n        var doc = EJSON.clone(fields);\n        doc._id = id;\n        var frag = Spark.render(_.bind(itemFunc, null, transformedDoc(doc)));\n        DomUtils.wrapFragmentForContainer(frag, outerRange.containerNode());\n        var range = makeRange(ANNOTATION_LIST_ITEM, frag);\n\n        if (itemDict.empty()) {\n          Spark.finalize(outerRange.replaceContents(frag));\n        } else if (before === null) {\n          itemDict.lastValue().liveRange.insertAfter(frag);\n        } else {\n          itemDict.get(before).liveRange.insertBefore(frag);\n        }\n        itemDict.putBefore(id, {doc: doc, liveRange: range}, before);\n      });\n    },\n\n    removed: function (id) {\n      later(function () {\n        if (itemDict.first() === itemDict.last()) {\n          var frag = Spark.render(elseFunc);\n          DomUtils.wrapFragmentForContainer(frag, outerRange.containerNode());\n          Spark.finalize(outerRange.replaceContents(frag));\n        } else\n          Spark.finalize(itemDict.get(id).liveRange.extract());\n\n        itemDict.remove(id);\n\n        notifyParentsRendered();\n      });\n    },\n\n    movedBefore: function (id, before) {\n      later(function () {\n        var frag = itemDict.get(id).liveRange.extract();\n        if (before === null) {\n          itemDict.lastValue().liveRange.insertAfter(frag);\n        } else {\n          itemDict.get(before).liveRange.insertBefore(frag);\n        }\n        itemDict.moveBefore(id, before);\n        notifyParentsRendered();\n      });\n    },\n\n    changed: function (id, fields) {\n      later(function () {\n        var elt = itemDict.get(id);\n        if (!elt)\n          throw new Error(\"Unknown id for changed: \" + id);\n        applyChanges(elt.doc, fields);\n        Spark.renderToRange(elt.liveRange,\n                            _.bind(itemFunc, null, transformedDoc(elt.doc)));\n      });\n    }\n  });\n\n  return html;\n};\n\n/******************************************************************************/\n/* Labels and landmarks                                                       */\n/******************************************************************************/\n\nvar nextLandmarkId = 1;\n\nSpark.Landmark = function () {\n  this.id = nextLandmarkId++;\n  this._range = null; // will be set when put onscreen\n};\n\n_.extend(Spark.Landmark.prototype, {\n  firstNode: function () {\n    return this._range.firstNode();\n  },\n  lastNode: function () {\n    return this._range.lastNode();\n  },\n  find: function (selector) {\n    var r = this._range;\n    return DomUtils.findClipped(r.containerNode(), selector,\n                                r.firstNode(), r.lastNode());\n  },\n  findAll: function (selector) {\n    var r = this._range;\n    return DomUtils.findAllClipped(r.containerNode(), selector,\n                                   r.firstNode(), r.lastNode());\n  },\n  hasDom: function () {\n    return !! this._range;\n  }\n});\n\nSpark.UNIQUE_LABEL = ['UNIQUE_LABEL'];\n\n// label must be a string.\n// or pass label === null to not drop a label after all (meaning that\n// this function is a noop)\n//\nSpark.labelBranch = function (label, htmlFunc) {\n  var renderer = currentRenderer.get();\n  if (! renderer || label === null)\n    return htmlFunc();\n\n  if (label === Spark.UNIQUE_LABEL)\n    label = Random.id();\n\n  renderer.currentBranch.pushLabel(label);\n  var html = htmlFunc();\n  var occupied = renderer.currentBranch.getNotes().occupied;\n  renderer.currentBranch.popLabel();\n\n  if (! occupied)\n    // don't create annotation if branch doesn't contain any landmarks.\n    // if this label isn't on an element-level HTML boundary, then that\n    // is certainly the case.\n    return html;\n\n  return renderer.annotate(\n    html, ANNOTATION_LABEL, { label: label });\n\n  // XXX what happens if the user doesn't use the return value, or\n  // doesn't use it directly, eg, swaps the branches of the tree\n  // around? \"that's an error?\" the result would be that the apparent\n  // branch path of a landmark at render time would be different from\n  // its apparent branch path in the actual document. seems like the\n  // answer is to have labelBranch not drop an annotation, and keep\n  // the branch label info outside of the DOM in a parallel tree of\n  // labels and landmarks (likely similar to the one we're already\n  // keeping?) a little tricky since not every node in the label tree\n  // is actually populated with a landmark? (though we could change\n  // that I guess -- they would be landmarks without any specific DOM\n  // nodes?)\n};\n\nSpark.createLandmark = function (options, htmlFunc) {\n  var renderer = currentRenderer.get();\n  if (! renderer) {\n    // no renderer -- create and destroy Landmark inline\n    var landmark = new Spark.Landmark;\n    options.created && options.created.call(landmark);\n    var html = htmlFunc(landmark);\n    options.destroyed && options.destroyed.call(landmark);\n    return html;\n  }\n\n  // Normalize preserve map\n  var preserve = {};\n  if (_.isArray(options.preserve))\n    _.each(options.preserve, function (selector) {\n      preserve[selector] = true;\n    });\n  else\n    preserve = options.preserve || {};\n  for (var selector in preserve)\n    if (typeof preserve[selector] !== 'function')\n      preserve[selector] = function () { return true; };\n\n  renderer.currentBranch.mark('occupied');\n  var notes = renderer.currentBranch.getNotes();\n  var landmark;\n  if (notes.originalRange) {\n    if (notes.originalRange.superceded)\n      throw new Error(\"Can't create second landmark in same branch\");\n    notes.originalRange.superceded = true; // prevent destroyed(), second match\n    landmark = notes.originalRange.landmark; // the old Landmark\n  } else {\n    landmark = new Spark.Landmark;\n    if (options.created) {\n      // Run callback outside the current Spark.isolate's deps context.\n      Deps.nonreactive(function () {\n        options.created.call(landmark);\n      });\n    }\n  }\n  notes.landmark = landmark;\n\n  var html = htmlFunc(landmark);\n  return renderer.annotate(\n    html, ANNOTATION_LANDMARK, function (range) {\n      if (! range) {\n        // annotation not used\n        options.destroyed && options.destroyed.call(landmark);\n        return;\n      }\n\n      _.extend(range, {\n        preserve: preserve,\n        constant: !! options.constant,\n        rendered: options.rendered || function () {},\n        destroyed: options.destroyed || function () {},\n        landmark: landmark,\n        finalize: function () {\n          if (! this.superceded) {\n            this.landmark._range = null;\n            this.destroyed.call(this.landmark);\n          }\n        }\n      });\n\n      landmark._range = range;\n      renderer.landmarkRanges.push(range);\n      // Help GC avoid an actual memory leak (#1157) by nulling the\n      // `renderer` local variable, which holds data structures about\n      // the preservation and patching performed during this rendering\n      // pass, including references to the old LiveRanges.  If\n      // `renderer` is retained by the LiveRange we initialize here,\n      // it creates a chain linking the new LiveRanges to the\n      // renderer, to the old LiveRanges, to the old renderer, etc.\n      //\n      // The reason the new LiveRange might retains `renderer` has to\n      // do with how V8 implements closures.  V8 considers\n      // `range.finalize` to close over `renderer`, even though it\n      // doesn't use it.  Because `renderer` is used by *some* nested\n      // closure, it apparently is retained by all nested closures as\n      // part of `Spark.createLandmark`'s function context.\n      renderer = null;\n    });\n};\n\nSparkTest.getEnclosingLandmark = function (node) {\n  var range = findRangeOfType(ANNOTATION_LANDMARK, node);\n  return range ? range.landmark : null;\n};\n","patch = function(tgtParent, srcParent, tgtBefore, tgtAfter, preservations,\n                 results) {\n\n  var copyFunc = function(t, s) {\n    LiveRange.transplantTag(TAG, t, s);\n  };\n\n  var patcher = new Patcher(\n    tgtParent, srcParent, tgtBefore, tgtAfter);\n\n\n  var visitNodes = function(parent, before, after, func) {\n    for(var n = before ? before.nextSibling : parent.firstChild;\n        n && n !== after;\n        n = n.nextSibling) {\n      if (func(n) !== false && n.firstChild)\n        visitNodes(n, null, null, func);\n    }\n  };\n\n  // results arg is optional; it is mutated if provided; returned either way\n  results = (results || {});\n  // array of LiveRanges that were successfully preserved from\n  // the region preservations\n  var regionPreservations = (results.regionPreservations =\n                             results.regionPreservations || []);\n\n  var lastTgtMatch = null;\n\n  visitNodes(srcParent, null, null, function(src) {\n    // XXX inefficient to scan for match for every node!\n    // We could at least skip non-element nodes, except for \"range matches\"\n    // used for constant chunks, which may begin on a non-element.\n    // But really this shouldn't be a linear search.\n    var pres = _.find(preservations, function (p) {\n      // find preserved region starting at `src`, if any\n      return p.type === 'region' && p.newRange.firstNode() === src;\n    }) || _.find(preservations, function (p) {\n      // else, find preservation of `src`\n      return p.type === 'node' && p.to === src;\n    });\n\n    if (pres) {\n      var tgt = (pres.type === 'region' ? pres.fromStart : pres.from);\n      if (! lastTgtMatch ||\n          DomUtils.compareElementIndex(lastTgtMatch, tgt) < 0) {\n        if (pres.type === 'region') {\n          // preserved region for constant landmark\n          if (patcher.match(pres.fromStart, pres.newRange.firstNode(),\n                            copyFunc, true)) {\n            patcher.skipToSiblings(pres.fromEnd, pres.newRange.lastNode());\n            // without knowing or caring what DOM nodes are in pres.newRange,\n            // transplant the range data to pres.fromStart and pres.fromEnd\n            // (including references to enclosing ranges).\n            LiveRange.transplantRange(\n              pres.fromStart, pres.fromEnd, pres.newRange);\n            regionPreservations.push(pres.newRange);\n          }\n        } else if (pres.type === 'node') {\n          if (patcher.match(tgt, src, copyFunc)) {\n            // match succeeded\n            lastTgtMatch = tgt;\n            if (tgt.firstChild || src.firstChild) {\n              if (tgt.nodeName !== \"TEXTAREA\" && tgt.nodeName !== \"SELECT\") {\n                // Don't patch contents of TEXTAREA tag (which are only the\n                // initial contents but may affect the tag's .value in IE) or of\n                // SELECT (which is specially handled in _copyAttributes).\n                // Otherwise recurse!\n                patch(tgt, src, null, null, preservations);\n              }\n            }\n            return false; // tell visitNodes not to recurse\n          }\n        }\n      }\n    }\n    return true;\n  });\n\n  patcher.finish();\n\n  return results;\n};\n\n\n// A Patcher manages the controlled replacement of a region of the DOM.\n// The target region is changed in place to match the source region.\n//\n// The target region consists of the children of tgtParent, extending from\n// the child after tgtBefore to the child before tgtAfter.  A null\n// or absent tgtBefore or tgtAfter represents the beginning or end\n// of tgtParent's children.  The source region consists of all children\n// of srcParent, which may be a DocumentFragment.\n//\n// To use a new Patcher, call `match` zero or more times followed by\n// `finish`.\n//\n// A match is a correspondence between an old node in the target region\n// and a new node in the source region that will replace it.  Based on\n// this correspondence, the target node is preserved and the attributes\n// and children of the source node are copied over it.  The `match`\n// method declares such a correspondence.  A Patcher that makes no matches,\n// for example, just removes the target nodes and inserts the source nodes\n// in their place.\n//\n// Constructor:\nPatcher = function(tgtParent, srcParent, tgtBefore, tgtAfter) {\n  this.tgtParent = tgtParent;\n  this.srcParent = srcParent;\n\n  this.tgtBefore = tgtBefore;\n  this.tgtAfter = tgtAfter;\n\n  this.lastKeptTgtNode = null;\n  this.lastKeptSrcNode = null;\n};\n\n\n// Advances the patching process up to tgtNode in the target tree,\n// and srcNode in the source tree.  tgtNode will be preserved, with\n// the attributes of srcNode copied over it, in essence identifying\n// the two nodes with each other.  The same treatment is given to\n// any parents of the nodes that are newly implicated as corresponding.\n// In the process of traversing from the last matched nodes to these\n// ones, all nodes \"in between\" in the target document, at any level,\n// are removed, and all nodes \"in between\" in the source document\n// are copied over to their appropriate positions.\n//\n// For example, if match() is called only once, and then finish()\n// is called, the effect is to preserve tgtNode, its children,\n// and its ancestors (parent chain), while swapping out all its\n// siblings and the siblings of its ancestors, so that the target\n// tree is mutated to look like the source tree did.\n//\n// The caller is responsible for ensuring the precondition that\n// subsequent tgtNodes and subsequent srcNodes are strictly \"in order.\"\n// The ordering referred to here is a partial order in which A comes\n// before B if their tags would be disjoint in HTML, i.e. the end of\n// A comes before the beginning of B.  Put another way, there is some\n// ancestor of A and some ancestor of B that have the same parent,\n// are different, and are in order.\n//\n// There are other requirements for two nodes to be \"matched,\"\n// but match() can detect them and exit gracefully returning false.\n// For example, the tag-names must be the same, and the tag-names\n// of their parents.  More subtly, it may be impossible to match\n// the parents of tgtNode or srcNode because they have been\n// previously matched.  If we are to match a series of P tags\n// that are each inside one DIV, for example, is it the same DIV\n// or not?  If the source and target disagree, we will have to\n// reparent one of the Ps.  Users should not be moving identified\n// nodes, but we want to still be correct (fall back on replacement)\n// if they do.\n//\n// If false is returned, the match was impossible, but patching\n// can continue and will still be otherwise correct.  The next call\n// to match() must still obey the order constraint, as the patcher\n// internally only moves forwards and patches as it goes.\n//\n// copyCallback is called on every new matched (tgt, src) pair\n// right after copying attributes.  It's a good time to transplant\n// liveranges and patch children.\nPatcher.prototype.match = function(\n  tgtNode, srcNode, copyCallback, onlyAdvance) {\n\n  // last nodes \"kept\" (matched/identified with each other)\n  var lastKeptTgt = this.lastKeptTgtNode;\n  var lastKeptSrc = this.lastKeptSrcNode;\n  // nodes to match and keep, this time around\n  var tgt = tgtNode;\n  var src = srcNode;\n\n  if ((! tgt) != (! src)) {\n    return false; // truthinesses don't match\n  }\n\n  var starting = ! lastKeptTgt;\n  var finishing = ! tgt;\n\n  if (! starting) {\n    // move lastKeptTgt/lastKeptSrc forward and out,\n    // until they are siblings of tgt/src or of an ancestor of tgt/src,\n    // replacing as we go.  If tgt/src is falsy, we make it to the\n    // top level.\n    while (lastKeptTgt.parentNode !== this.tgtParent &&\n           ! (tgt && DomUtils.elementContains(lastKeptTgt.parentNode, tgt))) {\n      // Last-kept nodes are inside parents that are not\n      // parents of the newly matched nodes.  Must finish\n      // replacing their contents and back out.\n      this._replaceNodes(lastKeptTgt, null, lastKeptSrc, null);\n      lastKeptTgt = lastKeptTgt.parentNode;\n      lastKeptSrc = lastKeptSrc.parentNode;\n    }\n\n    // update instance vars; there's no going back inside these nodes\n    this.lastKeptTgtNode = lastKeptTgt;\n    this.lastKeptSrcNode = lastKeptSrc;\n\n    // Make sure same number of levels of \"moving up\" are\n    // appropriate for src as well, i.e. we aren't trying\n    // to match <c> in (<a><b/><c/></a>, <a><b/></a><a><c/></a>)\n    // after matching <b>, or vice versa.  In other words,\n    // if tag names and depths match, but identities of parents\n    // are inconsistent relative to previous matches, we catch it\n    // here.  In the example, lastKeptTgt would be the <b/> node\n    // on the left, which is not sibling of <c/> or of an ancestor\n    // of <c/> on the right.  If the example were reversed,\n    // lastKeptTgt would be the first <a> node, which is an\n    // ancestor of <c/> on the left rather than a sibling of an\n    // ancestor.\n    if (! finishing &&\n        (DomUtils.elementContains(lastKeptSrc, src) ||\n         ! (lastKeptSrc.parentNode === this.srcParent ||\n            DomUtils.elementContains(lastKeptSrc.parentNode, src)))) {\n      return false;\n    }\n  }\n\n  if (finishing) {\n    this._replaceNodes(lastKeptTgt, null, lastKeptSrc, null,\n                       this.tgtParent, this.srcParent);\n  } else {\n    // Compare tag names and depths to make sure we can match nodes...\n    if (! onlyAdvance) {\n      if (tgt.nodeName !== src.nodeName)\n        return false;\n    }\n\n    // Look at tags of parents until we hit parent of last-kept,\n    // which we know is ok.\n    for(var a=tgt.parentNode, b=src.parentNode;\n        a !== (starting ? this.tgtParent : lastKeptTgt.parentNode);\n        a = a.parentNode, b = b.parentNode) {\n      if (b === (starting ? this.srcParent : lastKeptSrc.parentNode))\n        return false; // src is shallower, b hit top first\n      if (a.nodeName !== b.nodeName)\n        return false; // tag names don't match\n    }\n    if (b !== (starting ? this.srcParent : lastKeptSrc.parentNode)) {\n      return false; // src is deeper, b didn't hit top when a did\n    }\n\n    var firstIter = true;\n    // move tgt and src backwards and out, replacing as we go\n    while (true) {\n      if (! (firstIter && onlyAdvance)) {\n        if (tgt.nodeType === 1) /* ELEMENT */\n          Patcher._copyAttributes(tgt, src);\n        if (copyCallback)\n          copyCallback(tgt, src);\n      }\n\n      firstIter = false;\n\n      if ((starting ? this.tgtParent : lastKeptTgt.parentNode)\n          === tgt.parentNode) {\n        // we've worked our way up to the same level as the last-kept nodes\n        this._replaceNodes(lastKeptTgt, tgt, lastKeptSrc, src);\n        break;\n      } else {\n        this._replaceNodes(null, tgt, null, src);\n        // move up to keep (match) parents as well\n        tgt = tgt.parentNode;\n        src = src.parentNode;\n      }\n    }\n  }\n\n  this.lastKeptTgtNode = tgtNode;\n  this.lastKeptSrcNode = srcNode;\n\n  return true;\n};\n\n// After a match, skip ahead to later siblings of the last kept nodes,\n// without performing any replacements.\nPatcher.prototype.skipToSiblings = function(tgt, src) {\n  var lastTgt = this.lastKeptTgtNode;\n  var lastSrc = this.lastKeptSrcNode;\n\n  if (! (lastTgt && lastTgt.parentNode === tgt.parentNode))\n    return false;\n\n  if (! (lastSrc && lastSrc.parentNode === src.parentNode))\n    return false;\n\n  this.lastKeptTgtNode = tgt;\n  this.lastKeptSrcNode = src;\n\n  return true;\n};\n\n// Completes patching assuming no more matches.\n//\n// Patchers are single-use, so no more methods can be called\n// on the Patcher.\nPatcher.prototype.finish = function() {\n  return this.match(null, null);\n};\n\n// Replaces the siblings between tgtBefore and tgtAfter (exclusive on both\n// sides) with the siblings between srcBefore and srcAfter (exclusive on both\n// sides).  Falsy values indicate start or end of siblings as appropriate.\n//\n// Precondition: tgtBefore and tgtAfter have same parent; either may be falsy,\n// but not both, unless optTgtParent is provided.  Same with srcBefore/srcAfter.\nPatcher.prototype._replaceNodes = function(\n  tgtBefore, tgtAfter, srcBefore, srcAfter, optTgtParent, optSrcParent)\n{\n  var tgtParent = optTgtParent || (tgtBefore || tgtAfter).parentNode;\n  var srcParent = optSrcParent || (srcBefore || srcAfter).parentNode;\n\n  // deal with case where top level is a range\n  if (tgtParent === this.tgtParent) {\n    tgtBefore = tgtBefore || this.tgtBefore;\n    tgtAfter = tgtAfter || this.tgtAfter;\n  }\n  if (srcParent === this.srcParent) {\n    srcBefore = srcBefore || this.srcBefore;\n    srcAfter = srcAfter || this.srcAfter;\n  }\n\n\n  // remove old children\n  var n;\n  while ((n = tgtBefore ? tgtBefore.nextSibling : tgtParent.firstChild)\n         && n !== tgtAfter) {\n    tgtParent.removeChild(n);\n  }\n\n  // add new children\n  var m;\n  while ((m = srcBefore ? srcBefore.nextSibling : srcParent.firstChild)\n         && m !== srcAfter) {\n    tgtParent.insertBefore(m, tgtAfter || null);\n  }\n};\n\n// Copy HTML attributes of node `src` onto node `tgt`.\n//\n// The effect we are trying to achieve is best expresed in terms of\n// HTML.  Whatever HTML generated `tgt`, we want to mutate the DOM element\n// so that it is as if it were the HTML that generated `src`.\n// We want to preserve JavaScript properties in general (tgt.foo),\n// while syncing the HTML attributes (tgt.getAttribute(\"foo\")).\n//\n// This is complicated by form controls and the fact that old IE\n// can't keep the difference straight between properties and attributes.\nPatcher._copyAttributes = function(tgt, src) {\n  var srcAttrs = src.attributes;\n  var tgtAttrs = tgt.attributes;\n\n  // Determine whether tgt has focus; works in all browsers\n  // as of FF3, Safari4\n  var targetFocused = (tgt === document.activeElement);\n\n  ///// Clear current attributes\n\n  if (tgt.style.cssText)\n    tgt.style.cssText = '';\n\n  var isRadio = false;\n  var finalChecked = null;\n  if (tgt.nodeName === \"INPUT\") {\n    // Record for later whether this is a radio button.\n    isRadio = (tgt.type === 'radio');\n\n    // Figure out whether this should be checked or not. If the re-rendering\n    // changed its idea of checkedness, go with that; otherwsie go with whatever\n    // the control's current setting is.\n    if (isRadio || tgt.type === 'checkbox') {\n      var tgtOriginalChecked = !!tgt._sparkOriginalRenderedChecked &&\n            tgt._sparkOriginalRenderedChecked[0];\n      var srcOriginalChecked = !!src._sparkOriginalRenderedChecked &&\n            src._sparkOriginalRenderedChecked[0];\n      // For radio buttons, we previously saved the checkedness in an expando\n      // property before doing some DOM operations that could wipe it out. For\n      // checkboxes, we can just use the checked property directly.\n      var tgtCurrentChecked = tgt._currentChecked ?\n            tgt._currentChecked[0] : tgt.checked;\n      if (tgtOriginalChecked === srcOriginalChecked) {\n        finalChecked = tgtCurrentChecked;\n      } else {\n        finalChecked = srcOriginalChecked;\n        tgt._sparkOriginalRenderedChecked = [finalChecked];\n      }\n    }\n  }\n\n  for(var i=tgtAttrs.length-1; i>=0; i--) {\n    var attr = tgtAttrs[i];\n    // In old IE, attributes that are possible on a node\n    // but not actually present will show up in this loop\n    // with specified=false.  All other browsers support\n    // 'specified' (because it's part of the spec) and\n    // set it to true.\n    if (! attr.specified)\n      continue;\n    var name = attr.name;\n    // Filter out attributes that are indexable by number\n    // but not by name.  This kills the weird \"propdescname\"\n    // attribute in IE 8.\n    if (! tgtAttrs[name])\n      continue;\n    // Some properties don't mutate well, and we simply\n    // don't try to patch them.  For example, you can't\n    // change a control's type in IE.\n    if (name === \"id\" || name === \"type\")\n      continue;\n    // Removing a radio button's \"name\" property and restoring\n    // it is harmless in most browsers but breaks in IE 7.\n    // It seems unlikely enough that a radio button will\n    // sometimes have a group and sometimes not.\n    if (isRadio && name === \"name\")\n      continue;\n    // Never delete the \"value\" attribute: we have special three-way diff logic\n    // for it at the end.\n    if (name === \"value\")\n      continue;\n    // Removing 'src' (e.g. in an iframe) can only be bad.\n    if (name === \"src\")\n      continue;\n\n    // We want to patch any HTML attributes that were specified in the\n    // source, but preserve DOM properties set programmatically.\n    // Old IE makes this difficult by exposing properties as attributes.\n    // Expando properties will even appear in innerHTML, though not if the\n    // value is an object rather than a primitive.\n    //\n    // We use a heuristic to determine if we are looking at a programmatic\n    // property (an expando) rather than a DOM attribute.\n    //\n    // Losing jQuery's expando (whose value is a number) is very bad,\n    // because it points to event handlers that only jQuery can detach,\n    // and only if the expando is in place.\n    var possibleExpando = tgt[name];\n    if (possibleExpando &&\n        (typeof possibleExpando === \"object\" ||\n         /^jQuery/.test(name)))\n      continue; // for object properties that surface attributes only in IE\n    tgt.removeAttributeNode(attr);\n  }\n\n  ///// Copy over src's attributes\n\n  if (tgt.mergeAttributes) {\n    // IE code path:\n    //\n    // Only IE (all versions) has mergeAttributes.\n    // It's probably a good bit faster in old IE than\n    // iterating over all the attributes, and the treatment\n    // of form controls is sufficiently different in IE from\n    // other browsers that we keep the special cases separate.\n\n    // Don't copy _sparkOriginalRenderedValue, though.\n    var srcExpando = src._sparkOriginalRenderedValue;\n    src.removeAttribute('_sparkOriginalRenderedValue');\n\n    tgt.mergeAttributes(src);\n    if (srcExpando)\n      src._sparkOriginalRenderedValue = srcExpando;\n\n    if (src.name)\n      tgt.name = src.name;\n\n  } else {\n    // Non-IE code path:\n\n    for(var i=0, L=srcAttrs.length; i<L; i++) {\n      var srcA = srcAttrs.item(i);\n      if (srcA.specified) {\n        var name = srcA.name.toLowerCase();\n        var value = String(srcA.value);\n        if (name === \"type\") {\n        // can't change type of INPUT in IE; don't support it\n        } else if (name === \"checked\") {\n          // handled specially below\n        } else if (name === \"style\") {\n          tgt.style.cssText = src.style.cssText;\n        } else if (name === \"class\") {\n          tgt.className = src.className;\n        } else if (name === \"value\") {\n          // don't set attribute, just overwrite property\n          // (in next phase)\n        } else if (name === \"src\") {\n          // only set if different.  protects iframes\n          if (src.src !== tgt.src)\n            tgt.src = src.src;\n        } else {\n          try {\n            tgt.setAttribute(name, value);\n          } catch (e) {\n            throw new Error(\"Error copying attribute '\" + name + \"': \" + e);\n          }\n        }\n      }\n    }\n  }\n\n  var originalRenderedValue = function (node) {\n    if (!node._sparkOriginalRenderedValue)\n      return null;\n    return node._sparkOriginalRenderedValue[0];\n  };\n  var srcOriginalRenderedValue = originalRenderedValue(src);\n  var tgtOriginalRenderedValue = originalRenderedValue(tgt);\n\n  // Save the target's current value.\n  var tgtCurrentValue = DomUtils.getElementValue(tgt);\n\n  if (tgt.nodeName === \"SELECT\") {\n    // Copy over the descendents of the tag (eg, OPTIONs, OPTGROUPs, etc) so\n    // that we get the new version's OPTIONs. (We don't look for any more nested\n    // preserved regions inside the element.)\n    while (tgt.firstChild)\n      tgt.removeChild(tgt.firstChild);\n    while (src.firstChild)\n      tgt.insertBefore(src.firstChild, null);\n    // ... but preserve the original <SELECT>'s value if possible (ie, ignore\n    // any <OPTION SELECTED>s that we may have copied over).\n    DomUtils.setElementValue(tgt, tgtCurrentValue);\n  }\n\n  // We preserve the old element's value unless both of the following are true:\n  //   - The newly rendered value is different from the old rendered value: ie,\n  //     something has actually changed on the server.\n  //   - It's unfocused. If it's focused, the user might be editing it, and\n  //     we don't want to update what the user is currently editing (and lose\n  //     the selection, etc).\n  //\n  // After updating the element's value, we update its\n  // _sparkOriginalRenderedValue to match.\n  //\n  // There's a case where we choose to update _sparkOriginalRenderedValue even\n  // though we're not updating the visible value. That's when the element is\n  // focused (preventing us from updating the visible value), but the newly\n  // rendered value matches the visible value. In this case, updating the\n  // visible value would have been a no-op, so we can do the matching\n  // _sparkOriginalRenderedValue update.\n  //\n  // Note that we expect src._sparkOriginalRenderedValue[0] to be equal to\n  // src.value. For <LI>'s, though, there is a value property (the ordinal in\n  // the list) even though there is no value attribute (and thus no saved\n  // _sparkOriginalRenderedValue), so we do have to be sure to do the comparison\n  // with src._sparkOriginalRenderedValue[0] rather than with src.value.\n  if (srcOriginalRenderedValue !== tgtOriginalRenderedValue &&\n      (tgtCurrentValue === srcOriginalRenderedValue || !targetFocused)) {\n    // Update the on-screen value to the newly rendered value, but only if it's\n    // an actual change (a seemingly \"no-op\" value update resets the selection,\n    // so don't do that!)\n    if (tgtCurrentValue !== srcOriginalRenderedValue)\n      DomUtils.setElementValue(tgt, srcOriginalRenderedValue);\n    // ... and overwrite the saved rendered value too, so that the next time\n    // around we'll be comparing to this rendered value instead of the old one.\n    tgt._sparkOriginalRenderedValue = [srcOriginalRenderedValue];\n  }\n\n  // Deal with checkboxes and radios.\n  if (finalChecked !== null) {\n    // Don't do a no-op write to 'checked', since in some browsers that triggers\n    // events.\n    if (tgt.checked !== finalChecked)\n      tgt.checked = finalChecked;\n\n    // Set various other fields related to checkedness.\n    tgt.defaultChecked = finalChecked;\n    if (finalChecked)\n      tgt.setAttribute(\"checked\", \"checked\");\n    else\n      tgt.removeAttribute(\"checked\");\n  }\n};\n\nSparkTest.Patcher = Patcher;\n","Meteor.render = function (htmlFunc) {\n  return Spark.render(function () {\n    return Spark.isolate(\n      typeof htmlFunc === 'function' ? htmlFunc : function() {\n        // non-function argument becomes a constant (non-reactive) string\n        return String(htmlFunc);\n      });\n  });\n};\n\nMeteor.renderList = function (cursor, itemFunc, elseFunc) {\n  return Spark.render(function () {\n    return Spark.list(cursor, function (item) {\n      var label = item._id ? idStringify(item._id) : null;\n      return Spark.labelBranch(label, function () {\n        return Spark.isolate(_.bind(itemFunc, null, item));\n      });\n    }, function () {\n      return elseFunc ? Spark.isolate(elseFunc) : '';\n    });\n  });\n};\n","Spark._labelFromIdOrName = function(n) {\n  var label = null;\n\n  if (n.nodeType === 1 /*ELEMENT_NODE*/) {\n    if (n.getAttribute('id')) {\n      label = '#' + n.getAttribute('id');\n    } else if (n.getAttribute(\"name\")) {\n      label = n.getAttribute(\"name\");\n      // Radio button special case:  radio buttons\n      // in a group all have the same name.  Their value\n      // determines their identity.\n      // Checkboxes with the same name and different\n      // values are also sometimes used in apps, so\n      // we treat them similarly.\n      if (n.nodeName === 'INPUT' &&\n          (n.type === 'radio' || n.type === 'checkbox') &&\n          n.value)\n        label = label + ':' + n.value;\n\n      // include parent names and IDs up to enclosing ID\n      // in the label\n      while (n.parentNode &&\n             n.parentNode.nodeType === 1 /*ELEMENT_NODE*/) {\n        n = n.parentNode;\n        if (n.id) {\n          label = '#' + n.id + \"/\" + label;\n          break;\n        } else if (n.getAttribute('name')) {\n          label = n.getAttribute('name') + \"/\" + label;\n        }\n      }\n    }\n  }\n\n  return label;\n};\n"]}