{"version":3,"file":"/packages/liverange.js","sources":["liverange/liverange.js"],"names":[],"mappings":";;;;;;;;AAAA,wC;;AAEA,0E;AACA,qD;;AAEA,oE;AACA,oE;;AAEA,oC;AACA,oE;AACA,kD;AACA,6C;AACA,gB;AACA,O;AACA,wB;AACA,yB;AACA,4B;AACA,iB;;AAEA,mE;AACA,6D;AACA,sE;AACA,+B;AACA,oD;AACA,4B;AACA,iB;;AAEA,c;AACA,K;;AAEA,2C;AACA,wB;AACA,wB;AACA,U;AACA,kD;AACA,mD;AACA,gC;AACA,+C;AACA,qD;AACA,wD;AACA,0B;AACA,K;AACA,6C;AACA,qD;AACA,gE;AACA,wB;AACA,K;AACA,wB;AACA,G;AACA,E;;;AAGA,wD;AACA,E;AACA,kE;AACA,kE;AACA,gE;AACA,gE;AACA,iE;AACA,mE;AACA,oE;AACA,kE;AACA,oE;AACA,8D;AACA,4C;AACA,E;AACA,mE;AACA,8D;AACA,+D;AACA,+C;AACA,E;AACA,uD;AACA,iE;AACA,mE;AACA,+D;AACA,Y;AACA,E;AACA,gE;AACA,iE;AACA,kE;AACA,iD;AACA,E;AACA,gE;AACA,gE;AACA,iE;AACA,oE;AACA,+D;AACA,2D;AACA,E;AACA,+D;AACA,gC;AACA,+C;AACA,qD;AACA,0B;AACA,6B;AACA,U;AACA,2B;AACA,oE;AACA,G;AACA,qB;;AAEA,0D;;AAEA,4C;AACA,wC;AACA,sC;;AAEA,+D;AACA,iC;AACA,I;AACA,iE;AACA,gE;AACA,qE;AACA,iE;AACA,kE;AACA,gE;AACA,yB;AACA,I;AACA,wE;AACA,wD;AACA,I;AACA,wE;AACA,iE;;AAEA,wE;AACA,qE;;AAEA,mE;AACA,8D;AACA,iE;AACA,mE;AACA,iE;AACA,qD;AACA,yD;AACA,I;AACA,qE;AACA,6D;AACA,qE;AACA,kD;;AAEA,iE;AACA,oD;AACA,gD;AACA,E;;AAEA,8E;AACA,Y;AACA,6D;AACA,8D;AACA,kE;AACA,iE;AACA,8D;AACA,kE;AACA,mE;AACA,I;AACA,qE;AACA,sE;AACA,gE;AACA,sE;AACA,oE;AACA,qE;AACA,sE;AACA,wC;AACA,I;AACA,mE;AACA,oE;AACA,oE;AACA,kB;AACA,I;AACA,qD;AACA,2E;AACA,sD;AACA,mD;AACA,sB;AACA,6D;AACA,yC;AACA,4B;AACA,K;AACA,2B;AACA,gB;AACA,2B;AACA,4B;AACA,gB;AACA,Y;AACA,K;AACA,G;AACA,e;AACA,E;;AAEA,kD;AACA,0B;AACA,8B;AACA,c;AACA,E;;AAEA,qC;AACA,4D;AACA,oE;AACA,2C;AACA,gB;AACA,qB;AACA,O;AACA,mB;AACA,qB;AACA,kB;AACA,yB;AACA,gB;AACA,K;;AAEA,oD;AACA,uB;AACA,8D;AACA,0B;AACA,uB;AACA,Q;AACA,gC;AACA,G;AACA,E;;AAEA,oE;AACA,kE;AACA,gB;AACA,E;AACA,qE;AACA,oE;AACA,kE;AACA,kE;AACA,mB;AACA,E;AACA,mE;AACA,oD;AACA,kB;;AAEA,kB;AACA,wD;AACA,+C;;AAEA,yC;AACA,oB;AACA,4B;AACA,0B;AACA,O;AACA,gC;AACA,sB;AACA,wD;AACA,4D;AACA,kD;AACA,S;AACA,O;AACA,O;;AAEA,0D;AACA,6D;;AAEA,oC;AACA,yE;AACA,0C;AACA,0B;AACA,8B;AACA,gD;AACA,O;;AAEA,0D;AACA,gC;AACA,4C;AACA,8B;AACA,0C;AACA,K;;AAEA,mC;;AAEA,U;AACA,gF;AACA,0E;AACA,mC;AACA,G;AACA,E;;AAEA,6D;AACA,6C;AACA,qB;AACA,E;;AAEA,6D;AACA,4C;AACA,mB;AACA,E;;AAEA,qE;AACA,4C;AACA,gD;AACA,gC;AACA,E;;AAEA,gE;AACA,iE;AACA,mC;AACA,E;AACA,uD;AACA,kE;AACA,kE;AACA,2D;AACA,0B;AACA,E;AACA,+D;AACA,gE;AACA,8D;AACA,oC;AACA,E;AACA,kE;AACA,mC;AACA,6D;AACA,2C;AACA,yC;;AAEA,qB;;AAEA,sD;AACA,yC;AACA,gC;AACA,6D;AACA,0C;AACA,uD;AACA,mD;AACA,0C;AACA,0D;AACA,kC;AACA,sC;AACA,kC;AACA,8C;AACA,sD;AACA,iC;AACA,qB;AACA,c;AACA,oB;AACA,yD;AACA,6C;AACA,4B;AACA,O;AACA,qB;AACA,K;AACA,I;;AAEA,wD;AACA,E;;AAEA,wC;AACA,oC;AACA,gC;AACA,C;AACA,yC;AACA,a;AACA,0C;AACA,uC;AACA,+C;AACA,2C;AACA,2C;AACA,oC;AACA,G;;AAEA,4C;AACA,yB;AACA,yC;AACA,G;;AAEA,iB;AACA,E;;AAEA,oC;AACA,wC;AACA,C;AACA,oE;AACA,yC;AACA,kE;AACA,yC;AACA,mB;AACA,6B;AACA,+B;AACA,Y;AACA,+B;AACA,iC;AACA,K;AACA,G;AACA,E;;AAEA,uD;AACA,uD;AACA,oB;AACA,E;AACA,mD;AACA,kE;AACA,mC;AACA,mE;AACA,kB;AACA,E;AACA,yC;AACA,0D;AACA,2B;AACA,mE;;AAEA,kD;AACA,0B;AACA,wD;;AAEA,kC;AACA,0E;AACA,kE;AACA,wB;AACA,kB;AACA,kC;AACA,gC;AACA,0B;AACA,c;AACA,kB;AACA,gB;AACA,8E;AACA,K;;AAEA,mB;AACA,K;AACA,E;;;AAGA,uE;AACA,E;AACA,uE;AACA,+E;AACA,2E;AACA,8E;AACA,4E;AACA,2E;AACA,0B;AACA,E;AACA,0C;AACA,E;AACA,mE;AACA,0E;AACA,0B;AACA,+C;AACA,yC;AACA,6B;AACA,yB;;AAEA,kC;AACA,mB;AACA,kE;AACA,iB;AACA,uD;;AAEA,0C;AACA,4C;AACA,qC;;AAEA,iB;;AAEA,2C;AACA,+B;;AAEA,0B;;AAEA,gB;AACA,uE;AACA,c;AACA,wE;;AAEA,6C;AACA,gE;AACA,G;;AAEA,gC;AACA,qD;AACA,8C;AACA,4C;;AAEA,kC;;AAEA,mD;AACA,wE;;AAEA,a;AACA,E;;AAEA,oE;AACA,sE;AACA,2E;AACA,kC;AACA,E;AACA,wE;AACA,uE;AACA,oE;AACA,iE;;AAEA,wB;AACA,W;;AAEA,sB;AACA,oC;AACA,yB;;AAEA,kC;AACA,gC;;AAEA,iC;AACA,kC;AACA,kC;AACA,gC;AACA,8B;AACA,E;;AAEA,6E;AACA,yE;AACA,+E;AACA,+E;AACA,4E;AACA,0D;AACA,E;AACA,wE;AACA,gC;AACA,kE;AACA,gC;AACA,0B;AACA,gC;;AAEA,0B;AACA,mB;AACA,yE;AACA,0B;AACA,iB;AACA,8D;AACA,E;;AAEA,4D;AACA,sD;AACA,oB;AACA,mD;AACA,kC;;AAEA,gC;AACA,W;;AAEA,oB;AACA,yD;;AAEA,6D;AACA,4C;AACA,6B;AACA,sC;AACA,6D;AACA,+D;AACA,E;;AAEA,2D;AACA,sD;AACA,oB;AACA,kD;AACA,+B;;AAEA,8B;AACA,W;;AAEA,oB;AACA,iE;;AAEA,uD;AACA,oC;AACA,2B;AACA,8D;AACA,wD;AACA,iE;AACA,E;;AAEA,wD;AACA,sD;AACA,uD;AACA,a;AACA,E;AACA,qD;AACA,wD;AACA,4D;AACA,wD;AACA,0C;AACA,6B;AACA,0E;AACA,6E;AACA,yB;AACA,gB;AACA,G;;AAEA,2C;AACA,oC;AACA,sC;;AAEA,6B;AACA,mE;AACA,iC;AACA,2B;AACA,oC;AACA,+D;AACA,iE;AACA,G;;AAEA,2D;AACA,+D;AACA,uC;AACA,4B;AACA,8D;AACA,0D;AACA,mE;AACA,G;;AAEA,iD;;AAEA,Y;AACA,0D;AACA,wB;AACA,0B;;AAEA,gB;AACA,E;;AAEA,gE;AACA,8C;AACA,E;AACA,gE;AACA,gE;AACA,iE;AACA,iB;AACA,8D;AACA,yE;AACA,a;AACA,kB;;AAEA,wB;AACA,gB;;AAEA,6D;AACA,E;;AAEA,8D;AACA,2C;AACA,+C;AACA,a;AACA,kB;;AAEA,wB;AACA,gB;;AAEA,mD;AACA,E;;AAEA,yD;AACA,sD;AACA,oD;AACA,sD;AACA,yD;AACA,0D;;AAEA,sC;AACA,kB;;AAEA,sD;AACA,gE;AACA,qC;AACA,G;;AAEA,6B;AACA,gB;AACA,qB;AACA,8C;AACA,wC;AACA,wC;AACA,2B;AACA,oB;AACA,iC;AACA,K;AACA,oD;AACA,oC;AACA,4B;AACA,G;;AAEA,c;AACA,E","sourcesContent":["// Stand back, I'm going to try SCIENCE.\n\n// Possible optimization: get rid of _startIndex/_endIndex and just search\n// the list. Not clear which strategy will be faster.\n\n// Possible extension: could allow zero-length ranges is some cases,\n// by encoding both 'enter' and 'leave' type events in the same list\n\nvar canSetTextProps = (function () {\n  // IE8 and earlier don't support expando attributes on text nodes,\n  // but fortunately they are allowed on comments.\n  var testElem = document.createTextNode(\"\");\n  var exception;\n  try {\n    testElem.test = 123;\n  } catch (exception) { }\n  if (testElem.test !== 123)\n    return false;\n\n  // IE9 and 10 have a weird issue with multiple text nodes next to\n  // each other losing their expando attributes. Use the same\n  // workaround as IE8. Not sure how to test this as a feature, so use\n  // browser detection instead.\n  // See https://github.com/meteor/meteor/issues/458\n  if (document.documentMode)\n    return false;\n\n  return true;\n})();\n\nvar wrapEndpoints = function (start, end) {\n  if (canSetTextProps) {\n    return [start, end];\n  } else {\n    // IE8 workaround: insert some empty comments.\n    // Comments whose text is \"IE\" are stripped out\n    // in cross-browser testing.\n    if (start.nodeType === 3 /* text node */) {\n      var placeholder = document.createComment(\"IE\");\n      start.parentNode.insertBefore(placeholder, start);\n      start = placeholder;\n    }\n    if (end.nodeType === 3 /* text node */) {\n      var placeholder = document.createComment(\"IE\");\n      end.parentNode.insertBefore(placeholder, end.nextSibling);\n      end = placeholder;\n    }\n    return [start, end];\n  }\n};\n\n\n// This is a constructor (invoke it as 'new LiveRange').\n//\n// Create a range, tagged 'tag', that includes start, end, and all\n// the nodes between them, and the children of all of those nodes,\n// but includes no other nodes. If there are other ranges tagged\n// 'tag' that contain this exact set of nodes, then: if inner is\n// false (the default), the new range will be outside all of them\n// (will contain all of them), or if inner is true, then it will be\n// inside all of them (be contained by all of them.) If there are no\n// other ranges tagged 'tag' that contain this exact set of nodes,\n// then 'inner' is ignored because the nesting of the new range with\n// respect to other ranges is uniquely determined. (Nesting of\n// ranges with different tags is undefined.)\n//\n// To track the range as it's relocated, some of the DOM nodes that\n// are part of the range will have an expando attribute set on\n// them. The name of the expando attribute will be the value of\n// 'tag', so pick something that won't collide.\n//\n// Instead of start and end, you can pass a document or\n// documentfragment for start and leave end undefined. Or you can\n// pass a node for start and leave end undefined, in which case end\n// === start. If start and end are distinct nodes, they must be\n// siblings.\n//\n// You can set any attributes you like on the returned LiveRange\n// object, with two exceptions. First, attribute names that start\n// with '_' are reserved. Second, the attribute 'tag' contains the\n// tag name of this range and mustn't be changed.\n//\n// It would be possible to add a fast path through this function\n// when caller can promise that there is no range that starts on\n// start that does not end by end, and vice versa. eg: when start\n// and end are the first and last child of their parent respectively\n// or when caller is building up the range tree from the inside\n// out. Let's wait for the profiler to tell us to add this.\n//\n// XXX Should eventually support LiveRanges where start === end\n// and start.parentNode is null.\nLiveRange = function (tag, start, end, inner) {\n  if (start.nodeType === 11 /* DocumentFragment */) {\n    end = start.lastChild;\n    start = start.firstChild;\n  } else {\n    if (! start.parentNode)\n      throw new Error(\"LiveRange start and end must have a parent\");\n  }\n  end = end || start;\n\n  this.tag = tag; // must be set before calling _ensureTag\n\n  var endpoints = wrapEndpoints(start, end);\n  start = this._ensureTag(endpoints[0]);\n  end = this._ensureTag(endpoints[1]);\n\n  // Decide at what indices in start[tag][0] and end[tag][1] we\n  // should insert the new range.\n  //\n  // The start[tag][0] array lists the other ranges that start at\n  // `start`, and we must choose an insertion index that puts us\n  // inside the ones that end at later siblings, and outside the ones\n  // that end at earlier siblings.  The ones that end at the same\n  // sibling (i.e. share both our start and end) we must be inside\n  // or outside of depending on `inner`.  The array lists ranges\n  // from the outside in.\n  //\n  // The same logic applies to end[tag][1], which lists the other ranges\n  // that happen to end at `end` from in the inside out.\n  //\n  // Liveranges technically start just before, and end just after, their\n  // start and end nodes to which the liverange data is attached.\n\n  var startIndex = findPosition(start[tag][0], true, end, start, inner);\n  var endIndex = findPosition(end[tag][1], false, start, end, inner);\n\n  // this._start is the node N such that we begin before N, but not\n  // before the node before N in the preorder traversal of the\n  // document (if there is such a node.) this._start[this.tag][0]\n  // will be the list of all LiveRanges for which this._start is N,\n  // including us, sorted in the order that the ranges start. and\n  // finally, this._startIndex is the value such that\n  // this._start[this.tag][0][this._startIndex] === this.\n  //\n  // Similarly for this._end, except it's the node N such that we end\n  // after N, but not after the node after N in the postorder\n  // traversal; and the data is stored in this._end[this.tag][1], and\n  // it's sorted in the order that the ranges end.\n\n  // Set this._start, this._end, this._startIndex, this._endIndex\n  this._insertEntries(start, 0, startIndex, [this]);\n  this._insertEntries(end, 1, endIndex, [this]);\n};\n\nvar findPosition = function(ranges, findEndNotStart, edge, otherEdge, inner) {\n  var index;\n  // For purpose of finding where we belong in start[tag][0],\n  // walk the array and determine where we start to see ranges\n  // end at `end` (==edge) or earlier.  For the purpose of finding\n  // where we belong in end[tag][1], walk the array and determine\n  // where we start to see ranges start at `start` (==edge) or\n  // earlier.  In both cases, we slide a sibling pointer backwards\n  // looking for `edge`, though the details are slightly different.\n  //\n  // Use `inner` to take first or last candidate index for insertion.\n  // Candidate indices are:  Right before a range whose edge is `edge`\n  // (i.e., a range with same start and end as we are creating),\n  // or the index where ranges start to have edges earlier than `edge`\n  // (treating the end of the list as such an index).  We detect the\n  // latter case when `n` hits `edge` without hitting the edge of the\n  // current range; that is, it is about to move past `edge`.  This is\n  // always an appropriate time to stop.\n  //\n  // Joint traversal of the array and DOM should be fast.  The most\n  // expensive thing to happen would be a single walk from lastChild\n  // to end looking for range ends, or from end to start looking for\n  // range starts.\n  //\n  // invariant: n >= edge (\"n is after, or is, edge\")\n  var initialN = (findEndNotStart ? edge.parentNode.lastChild : otherEdge);\n  var takeFirst = (findEndNotStart ? ! inner : inner);\n  for(var i=0, n=initialN; i<=ranges.length; i++) {\n    var r = ranges[i];\n    var curEdge = r && (findEndNotStart ? r._end : r._start);\n    while (n !== curEdge && n !== edge) {\n      n = n.previousSibling;\n    }\n    if (curEdge === edge) {\n      index = i;\n      if (takeFirst) break;\n    } else if (n === edge) {\n      index = i;\n      break;\n    }\n  }\n  return index;\n};\n\nLiveRange.prototype._ensureTag = function (node) {\n  if (!(this.tag in node))\n    node[this.tag] = [[], []];\n  return node;\n};\n\nvar canDeleteExpandos = (function() {\n  // IE7 can't remove expando attributes from DOM nodes with\n  // delete. Instead you must remove them with node.removeAttribute.\n  var node = document.createElement(\"DIV\");\n  var exception;\n  var result = false;\n  try {\n    node.test = 12;\n    delete node.test;\n    result = true;\n  } catch (exception) { }\n  return result;\n})();\n\nLiveRange._cleanNode = function (tag, node, force) {\n  var data = node[tag];\n  if (data && (!(data[0].length + data[1].length) || force)) {\n    if (canDeleteExpandos)\n      delete node[tag];\n    else\n      node.removeAttribute(tag);\n  }\n};\n\n// Delete a LiveRange. This is analogous to removing a DOM node from\n// its parent -- it will no longer appear when traversing the tree\n// with visit().\n//\n// On modern browsers there is no requirement to delete LiveRanges on\n// defunct nodes. They will be garbage collected just like any other\n// object. However, on old versions of IE, you probably do need to\n// manually remove all ranges because IE can't GC reference cycles\n// through the DOM.\n//\n// Pass true for `recursive` to also destroy all descendent ranges.\nLiveRange.prototype.destroy = function (recursive) {\n  var self = this;\n\n  if (recursive) {\n    // recursive case: destroy all descendent ranges too\n    // (more efficient than actually recursing)\n\n    this.visit(function(isStart, range) {\n      if (isStart) {\n        range._start = null;\n        range._end = null;\n      }\n    }, function(isStart, node) {\n      if (! isStart) {\n        // when leaving a node, force-clean its children\n        for(var n = node.firstChild; n; n = n.nextSibling) {\n          LiveRange._cleanNode(self.tag, n, true);\n        }\n      }\n    });\n\n    this._removeEntries(this._start, 0, this._startIndex);\n    this._removeEntries(this._end, 1, 0, this._endIndex + 1);\n\n    if (this._start !== this._end) {\n      // force-clean the top-level nodes in this, besides _start and _end\n      for(var n = this._start.nextSibling;\n          n !== this._end;\n          n = n.nextSibling) {\n        LiveRange._cleanNode(self.tag, n, true);\n      }\n\n      // clean ends on this._start and starts on this._end\n      if (this._start[self.tag])\n        this._removeEntries(this._start, 1);\n      if (this._end[self.tag])\n        this._removeEntries(this._end, 0);\n    }\n\n    this._start = this._end = null;\n\n  } else {\n    this._removeEntries(this._start, 0, this._startIndex, this._startIndex + 1);\n    this._removeEntries(this._end, 1, this._endIndex, this._endIndex + 1);\n    this._start = this._end = null;\n  }\n};\n\n// Return the first node in the range (in preorder traversal)\nLiveRange.prototype.firstNode = function () {\n  return this._start;\n};\n\n// Return the last node in the range (in postorder traversal)\nLiveRange.prototype.lastNode = function () {\n  return this._end;\n};\n\n// Return the node that immediately contains this LiveRange, that is,\n// the parentNode of firstNode and lastNode.\nLiveRange.prototype.containerNode = function() {\n  return this._start.parentNode;\n};\n\n// Walk through the current contents of a LiveRange, enumerating\n// either the contained ranges (with the same tag as this range),\n// the contained elements, or both.\n//\n// visitRange(isStart, range) is invoked for each range\n// start-point or end-point that we encounter as we walk the range\n// stored in 'this' (not counting the endpoints of 'this' itself.)\n// visitNode(isStart, node) is similar but for nodes.  Both\n// functions are optional.\n//\n// If you return false (i.e. a value === false) from visitRange\n// or visitNode when isStart is true, the children of that range\n// or node are skipped, and the next callback will be the same\n// range or node with isStart false.\n//\n// If you create or destroy ranges with this tag from a visitation\n// function, results are undefined!\nLiveRange.prototype.visit = function(visitRange, visitNode) {\n  visitRange = visitRange || function() {};\n  visitNode = visitNode || function() {};\n\n  var tag = this.tag;\n\n  var recurse = function(start, end, startRangeSkip) {\n    var startIndex = startRangeSkip || 0;\n    var after = end.nextSibling;\n    for(var n = start; n && n !== after; n = n.nextSibling) {\n      var startData = n[tag] && n[tag][0];\n      if (startData && startIndex < startData.length) {\n        // immediate child range that starts with n\n        var range = startData[startIndex];\n        // be robust if visitRange mutates _start or _end;\n        // useful in destroy(true)\n        var rangeStart = range._start;\n        var rangeEnd = range._end;\n        if (visitRange(true, range) !== false)\n          recurse(rangeStart, rangeEnd, startIndex+1);\n        visitRange(false, range);\n        n = rangeEnd;\n      } else {\n        // bare node\n        if (visitNode(true, n) !== false && n.firstChild)\n          recurse(n.firstChild, n.lastChild);\n        visitNode(false, n);\n      }\n      startIndex = 0;\n    }\n  };\n\n  recurse(this._start, this._end, this._startIndex + 1);\n};\n\n// startEnd === 0 for starts, 1 for ends\nLiveRange.prototype._removeEntries =\n  function(node, startEnd, i, j)\n{\n  var entries = node[this.tag][startEnd];\n  i = i || 0;\n  j = (j || j === 0) ? j : entries.length;\n  var removed = entries.splice(i, j-i);\n  // fix up remaining ranges (not removed ones)\n  for(var a = i; a < entries.length; a++) {\n    if (startEnd) entries[a]._endIndex = a;\n    else entries[a]._startIndex = a;\n  }\n\n  // potentially remove empty liverange data\n  if (! entries.length) {\n    LiveRange._cleanNode(this.tag, node);\n  }\n\n  return removed;\n};\n\nLiveRange.prototype._insertEntries =\n  function(node, startEnd, i, newRanges)\n{\n  // insert the new ranges and \"adopt\" them by setting node pointers\n  var entries = node[this.tag][startEnd];\n  Array.prototype.splice.apply(entries, [i, 0].concat(newRanges));\n  for(var a=i; a < entries.length; a++) {\n    if (startEnd) {\n      entries[a]._end = node;\n      entries[a]._endIndex = a;\n    } else {\n      entries[a]._start = node;\n      entries[a]._startIndex = a;\n    }\n  }\n};\n\n// Replace the contents of this range with the provided\n// DocumentFragment. Returns the previous contents as a\n// DocumentFragment.\n//\n// \"The right thing happens\" with child LiveRanges:\n// - If there were child LiveRanges inside us, they will end up in\n//   the returned DocumentFragment.\n// - If the input DocumentFragment has LiveRanges, they will become\n//   our children.\n//\n// It is illegal for newFrag to be empty.\nLiveRange.prototype.replaceContents = function (newFrag) {\n  if (! newFrag.firstChild)\n    throw new Error(\"replaceContents requires non-empty fragment\");\n\n  return this.operate(function(oldStart, oldEnd) {\n    // Insert new fragment\n    oldStart.parentNode.insertBefore(newFrag, oldStart);\n\n    // Pull out departing fragment\n    // Possible optimization: use W3C Ranges on browsers that support them\n    var retFrag = oldStart.ownerDocument.createDocumentFragment();\n    var walk = oldStart;\n    while (true) {\n      var next = walk.nextSibling;\n      retFrag.appendChild(walk);\n      if (walk === oldEnd)\n        break;\n      walk = next;\n      if (!walk)\n        throw new Error(\"LiveRanges must begin and end on siblings in order\");\n    }\n\n    return retFrag;\n  });\n};\n\n\n// Perform a user-specified DOM mutation on the contents of this range.\n//\n// `func` is called with two parameters, `oldStart` and `oldEnd`, equal\n// to the original firstNode() and lastNode() of this range.  `func` is allowed\n// to perform arbitrary operations on the sequence of nodes from `oldStart`\n// to `oldEnd` and on child ranges of this range.  `func` may NOT call methods\n// on this range itself or otherwise rely on the existence of this range and\n// enclosing ranges.  `func` must leave at least one node to become the new\n// contents of this range.\n//\n// The return value of `func` is returned.\n//\n// This method is a generalization of replaceContents that works by\n// temporarily removing this LiveRange from the DOM and restoring it after\n// `func` has been called.\nLiveRange.prototype.operate = function (func) {\n  // boundary nodes of departing fragment\n  var oldStart = this._start;\n  var oldEnd = this._end;\n\n  // pull off outer liverange data\n  var outerStarts =\n        this._removeEntries(oldStart, 0, 0, this._startIndex + 1);\n  var outerEnds =\n        this._removeEntries(oldEnd, 1, this._endIndex);\n\n  var containerNode = oldStart.parentNode;\n  var beforeNode = oldStart.previousSibling;\n  var afterNode = oldEnd.nextSibling;\n\n  var ret = null;\n\n  // perform user-specifiedDOM manipulation\n  ret = func(oldStart, oldEnd);\n\n  // see what we've got...\n\n  var newStart =\n        beforeNode ? beforeNode.nextSibling : containerNode.firstChild;\n  var newEnd =\n        afterNode ? afterNode.previousSibling : containerNode.lastChild;\n\n  if (! newStart || newStart === afterNode) {\n    throw new Error(\"Ranges must contain at least one element\");\n  }\n\n  // wrap endpoints if necessary\n  var newEndpoints = wrapEndpoints(newStart, newEnd);\n  newStart = this._ensureTag(newEndpoints[0]);\n  newEnd = this._ensureTag(newEndpoints[1]);\n\n  // put the outer liveranges back\n\n  this._insertEntries(newStart, 0, 0, outerStarts);\n  this._insertEntries(newEnd, 1, newEnd[this.tag][1].length, outerEnds);\n\n  return ret;\n};\n\n// Move all liverange data represented in the DOM from sourceNode to\n// targetNode.  targetNode must be capable of receiving liverange tags\n// (for example, a node that has been the first or last node of a liverange\n// before; not a text node in IE).\n//\n// This is a low-level operation suitable for moving liveranges en masse\n// from one DOM tree to another, where transplantTag is called on every\n// pair of nodes such that targetNode takes the place of sourceNode.\nLiveRange.transplantTag = function(tag, targetNode, sourceNode) {\n\n  if (! sourceNode[tag])\n    return;\n\n  // copy data pointer\n  targetNode[tag] = sourceNode[tag];\n  sourceNode[tag] = null;\n\n  var starts = targetNode[tag][0];\n  var ends = targetNode[tag][1];\n\n  // fix _start and _end pointers\n  for(var i=0;i<starts.length;i++)\n    starts[i]._start = targetNode;\n  for(var i=0;i<ends.length;i++)\n    ends[i]._end = targetNode;\n};\n\n// Takes two sibling nodes tgtStart and tgtEnd with no LiveRange data on them\n// and a LiveRange srcRange in a separate DOM tree.  Transplants srcRange\n// to span from tgtStart to tgtEnd, and also copies info about enclosing ranges\n// starting on srcRange._start or ending on srcRange._end.  tgtStart and tgtEnd\n// must be capable of receiving liverange tags (for example, nodes that have\n// held liverange data in the past; not text nodes in IE).\n//\n// This is a low-level operation suitable for moving liveranges en masse\n// from one DOM tree to another.\nLiveRange.transplantRange = function(tgtStart, tgtEnd, srcRange) {\n  srcRange._ensureTag(tgtStart);\n  if (tgtEnd !== tgtStart)\n    srcRange._ensureTag(tgtEnd);\n\n  srcRange._insertEntries(\n    tgtStart, 0, 0,\n    srcRange._start[srcRange.tag][0].slice(0, srcRange._startIndex + 1));\n  srcRange._insertEntries(\n    tgtEnd, 1, 0,\n    srcRange._end[srcRange.tag][1].slice(srcRange._endIndex));\n};\n\n// Inserts a DocumentFragment immediately before this range.\n// The new nodes are outside this range but inside all\n// enclosing ranges.\nLiveRange.prototype.insertBefore = function(frag) {\n  var fragStart = frag.firstChild;\n\n  if (! fragStart) // empty frag\n    return;\n\n  // insert into DOM\n  this._start.parentNode.insertBefore(frag, this._start);\n\n  // move starts of ranges that begin on this._start, but are\n  // outside this, to beginning of fragStart\n  this._ensureTag(fragStart);\n  this._insertEntries(fragStart, 0, 0,\n                       this._removeEntries(this._start, 0, 0,\n                                            this._startIndex));\n};\n\n// Inserts a DocumentFragment immediately after this range.\n// The new nodes are outside this range but inside all\n// enclosing ranges.\nLiveRange.prototype.insertAfter = function(frag) {\n  var fragEnd = frag.lastChild;\n\n  if (! fragEnd) // empty frag\n    return;\n\n  // insert into DOM\n  this._end.parentNode.insertBefore(frag, this._end.nextSibling);\n\n  // move ends of ranges that end on this._end, but are\n  // outside this, to end of fragEnd\n  this._ensureTag(fragEnd);\n  this._insertEntries(fragEnd, 1, fragEnd[this.tag][1].length,\n                       this._removeEntries(this._end, 1,\n                                            this._endIndex + 1));\n};\n\n// Extracts this range and its contents from the DOM and\n// puts it into a DocumentFragment, which is returned.\n// All nodes and ranges outside this range are properly\n// preserved.\n//\n// Because liveranges must contain at least one node,\n// it is illegal to perform `extract` if the immediately\n// enclosing range would become empty.  If this precondition\n// is violated, no action is taken and null is returned.\nLiveRange.prototype.extract = function() {\n  if (this._startIndex > 0 &&\n      this._start[this.tag][0][this._startIndex - 1]._end === this._end) {\n    // immediately enclosing range wraps same nodes, so can't extract because\n    // it would empty it.\n    return null;\n  }\n\n  var before = this._start.previousSibling;\n  var after = this._end.nextSibling;\n  var parent = this._start.parentNode;\n\n  if (this._startIndex > 0) {\n    // must be a later node where outer ranges that start here end;\n    // move their starts to after\n    this._ensureTag(after);\n    this._insertEntries(after, 0, 0,\n                         this._removeEntries(this._start, 0, 0,\n                                              this._startIndex));\n  }\n\n  if (this._endIndex < this._end[this.tag][1].length - 1) {\n    // must be an earlier node where outer ranges that end here\n    // start; move their ends to before\n    this._ensureTag(before);\n    this._insertEntries(before, 1, before[this.tag][1].length,\n                         this._removeEntries(this._end, 1,\n                                              this._endIndex + 1));\n  }\n\n  var result = document.createDocumentFragment();\n\n  for(var n;\n      n = before ? before.nextSibling : parent.firstChild,\n      n && n !== after;)\n    result.appendChild(n);\n\n  return result;\n};\n\n// Find the immediately enclosing parent range of this range, or\n// null if this range has no enclosing ranges.\n//\n// If `withSameContainer` is true, we stop looking when we reach\n// this range's container node (the parent of its endpoints) and\n// only return liveranges whose first and last nodes are siblings\n// of this one's.\nLiveRange.prototype.findParent = function(withSameContainer) {\n  var result = enclosingRangeSearch(this.tag, this._end, this._endIndex);\n  if (result)\n    return result;\n\n  if (withSameContainer)\n    return null;\n\n  return LiveRange.findRange(this.tag, this.containerNode());\n};\n\n// Find the nearest enclosing range containing `node`, if any.\nLiveRange.findRange = function(tag, node) {\n  var result = enclosingRangeSearch(tag, node);\n  if (result)\n    return result;\n\n  if (! node.parentNode)\n    return null;\n\n  return LiveRange.findRange(tag, node.parentNode);\n};\n\nvar enclosingRangeSearch = function(tag, end, endIndex) {\n  // Search for an enclosing range, at the same level,\n  // starting at node `end` or after the range whose\n  // position in the end array of `end` is `endIndex`.\n  // The search works by scanning forwards for range ends\n  // while skipping over ranges whose starts we encounter.\n\n  if (typeof endIndex === \"undefined\")\n    endIndex = -1;\n\n  if (end[tag] && endIndex + 1 < end[tag][1].length) {\n    // immediately enclosing range ends at same node as this one\n    return end[tag][1][endIndex + 1];\n  }\n\n  var node = end.nextSibling;\n  while (node) {\n    var endIndex = 0;\n    var startData = node[tag] && node[tag][0];\n    if (startData && startData.length) {\n      // skip over sibling of this range\n      var r = startData[0];\n      node = r._end;\n      endIndex = r._endIndex + 1;\n    }\n    if (node[tag] && endIndex < node[tag][1].length)\n      return node[tag][1][endIndex];\n    node = node.nextSibling;\n  }\n\n  return null;\n};\n"]}