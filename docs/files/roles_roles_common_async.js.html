<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>roles/roles_common_async.js - The meteor-roles API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="The meteor-roles API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: v4.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Roles.html">Roles</a></li>
                                <li><a href="../classes/UIHelpers.html">UIHelpers</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/Roles.html">Roles</a></li>
                                <li><a href="../modules/UIHelpers.html">UIHelpers</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: roles/roles_common_async.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* global Roles */
import { Meteor } from &#x27;meteor/meteor&#x27;
import { Mongo } from &#x27;meteor/mongo&#x27;

/**
 * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.
 *
 * Roles are accessible throgh &#x60;Meteor.roles&#x60; collection and documents consist of:
 *  - &#x60;_id&#x60;: role name
 *  - &#x60;children&#x60;: list of subdocuments:
 *    - &#x60;_id&#x60;
 *
 * Children list elements are subdocuments so that they can be easier extended in the future or by plugins.
 *
 * Roles can have multiple parents and can be children (subroles) of multiple roles.
 *
 * Example: &#x60;{_id: &#x27;admin&#x27;, children: [{_id: &#x27;editor&#x27;}]}&#x60;
 *
 * The assignment of a role to a user is stored in a collection, accessible through &#x60;Meteor.roleAssignment&#x60;.
 * It&#x27;s documents consist of
 *  - &#x60;_id&#x60;: Internal MongoDB id
 *  - &#x60;role&#x60;: A role object which got assigned. Usually only contains the &#x60;_id&#x60; property
 *  - &#x60;user&#x60;: A user object, usually only contains the &#x60;_id&#x60; property
 *  - &#x60;scope&#x60;: scope name
 *  - &#x60;inheritedRoles&#x60;: A list of all the roles objects inherited by the assigned role.
 *
 * @module Roles
 */
export const RolesCollection = new Mongo.Collection(&#x27;roles&#x27;)

if (!Meteor.roles) {
  Meteor.roles = RolesCollection
}

export const RoleAssignmentCollection = new Mongo.Collection(&#x27;role-assignment&#x27;)

if (!Meteor.roleAssignment) {
  Meteor.roleAssignment = RoleAssignmentCollection
}

/**
 * @class Roles
 */
if (typeof Roles === &#x27;undefined&#x27;) {
  Roles = {} // eslint-disable-line no-global-assign
}

let getGroupsForUserDeprecationWarning = false

/**
 * Helper, resolves async some
 * @param {*} arr
 * @param {*} predicate
 * @returns {Promise&lt;Boolean&gt;}
 */
const asyncSome = async (arr, predicate) =&gt; {
  for (const e of arr) {
    if (await predicate(e)) return true
  }
  return false
}

Object.assign(Roles, {
  /**
   * Used as a global group (now scope) name. Not used anymore.
   *
   * @property GLOBAL_GROUP
   * @static
   * @deprecated
   */
  GLOBAL_GROUP: null,

  /**
   * Create a new role.
   *
   * @method createRoleAsync
   * @param {String} roleName Name of role.
   * @param {Object} [options] Options:
   *   - &#x60;unlessExists&#x60;: if &#x60;true&#x60;, exception will not be thrown in the role already exists
   * @return {Promise&lt;String&gt;} ID of the new role or null.
   * @static
   */
  createRoleAsync: async function (roleName, options) {
    Roles._checkRoleName(roleName)

    options = Object.assign(
      {
        unlessExists: false
      },
      options
    )

    let insertedId = null

    const existingRole = await Meteor.roles.findOneAsync({ _id: roleName })

    if (existingRole) {
      await Meteor.roles.updateAsync(
        { _id: roleName },
        { $setOnInsert: { children: [] } }
      )
      return null
    } else {
      insertedId = await Meteor.roles.insertAsync({
        _id: roleName,
        children: []
      })
    }

    if (!insertedId) {
      if (options.unlessExists) return null
      throw new Error(&quot;Role &#x27;&quot; + roleName + &quot;&#x27; already exists.&quot;)
    }

    return insertedId
  },

  /**
   * Delete an existing role.
   *
   * If the role is set for any user, it is automatically unset.
   *
   * @method deleteRoleAsync
   * @param {String} roleName Name of role.
   * @returns {Promise}
   * @static
   */
  deleteRoleAsync: async function (roleName) {
    let roles
    let inheritedRoles

    Roles._checkRoleName(roleName)

    // Remove all assignments
    await Meteor.roleAssignment.removeAsync({
      &#x27;role._id&#x27;: roleName
    })

    do {
      // For all roles who have it as a dependency ...
      roles = await Roles._getParentRoleNamesAsync(
        await Meteor.roles.findOneAsync({ _id: roleName })
      )

      for (const r of await Meteor.roles
        .find({ _id: { $in: roles } })
        .fetchAsync()) {
        await Meteor.roles.updateAsync(
          {
            _id: r._id
          },
          {
            $pull: {
              children: {
                _id: roleName
              }
            }
          }
        )

        inheritedRoles = await Roles._getInheritedRoleNamesAsync(
          await Meteor.roles.findOneAsync({ _id: r._id })
        )
        await Meteor.roleAssignment.updateAsync(
          {
            &#x27;role._id&#x27;: r._id
          },
          {
            $set: {
              inheritedRoles: [r._id, ...inheritedRoles].map((r2) =&gt; ({
                _id: r2
              }))
            }
          },
          { multi: true }
        )
      }
    } while (roles.length &gt; 0)

    // And finally remove the role itself
    await Meteor.roles.removeAsync({ _id: roleName })
  },

  /**
   * Rename an existing role.
   *
   * @method renameRoleAsync
   * @param {String} oldName Old name of a role.
   * @param {String} newName New name of a role.
   * @returns {Promise}
   * @static
   */
  renameRoleAsync: async function (oldName, newName) {
    let count

    Roles._checkRoleName(oldName)
    Roles._checkRoleName(newName)

    if (oldName === newName) return

    const role = await Meteor.roles.findOneAsync({ _id: oldName })

    if (!role) {
      throw new Error(&quot;Role &#x27;&quot; + oldName + &quot;&#x27; does not exist.&quot;)
    }

    role._id = newName

    await Meteor.roles.insertAsync(role)

    do {
      count = await Meteor.roleAssignment.updateAsync(
        {
          &#x27;role._id&#x27;: oldName
        },
        {
          $set: {
            &#x27;role._id&#x27;: newName
          }
        },
        { multi: true }
      )
    } while (count &gt; 0)

    do {
      count = await Meteor.roleAssignment.updateAsync(
        {
          &#x27;inheritedRoles._id&#x27;: oldName
        },
        {
          $set: {
            &#x27;inheritedRoles.$._id&#x27;: newName
          }
        },
        { multi: true }
      )
    } while (count &gt; 0)

    do {
      count = await Meteor.roles.updateAsync(
        {
          &#x27;children._id&#x27;: oldName
        },
        {
          $set: {
            &#x27;children.$._id&#x27;: newName
          }
        },
        { multi: true }
      )
    } while (count &gt; 0)

    await Meteor.roles.removeAsync({ _id: oldName })
  },

  /**
   * Add role parent to roles.
   *
   * Previous parents are kept (role can have multiple parents). For users which have the
   * parent role set, new subroles are added automatically.
   *
   * @method addRolesToParentAsync
   * @param {Array|String} rolesNames Name(s) of role(s).
   * @param {String} parentName Name of parent role.
   * @returns {Promise}
   * @static
   */
  addRolesToParentAsync: async function (rolesNames, parentName) {
    // ensure arrays
    if (!Array.isArray(rolesNames)) rolesNames = [rolesNames]

    for (const roleName of rolesNames) {
      await Roles._addRoleToParentAsync(roleName, parentName)
    }
  },

  /**
   * @method _addRoleToParentAsync
   * @param {String} roleName Name of role.
   * @param {String} parentName Name of parent role.
   * @returns {Promise}
   * @private
   * @static
   */
  _addRoleToParentAsync: async function (roleName, parentName) {
    Roles._checkRoleName(roleName)
    Roles._checkRoleName(parentName)

    // query to get role&#x27;s children
    const role = await Meteor.roles.findOneAsync({ _id: roleName })

    if (!role) {
      throw new Error(&#x60;Role &#x27;${roleName}&#x27; does not exist.&#x60;)
    }

    // detect cycles
    if ((await Roles._getInheritedRoleNamesAsync(role)).includes(parentName)) {
      throw new Error(
        &#x60;Roles &#x27;${roleName}&#x27; and &#x27;${parentName}&#x27; would form a cycle.&#x60;
      )
    }

    const count = await Meteor.roles.updateAsync(
      {
        _id: parentName,
        &#x27;children._id&#x27;: {
          $ne: role._id
        }
      },
      {
        $push: {
          children: {
            _id: role._id
          }
        }
      }
    )

    // if there was no change, parent role might not exist, or role is
    // already a sub-role; in any case we do not have anything more to do
    if (!count) return

    await Meteor.roleAssignment.updateAsync(
      {
        &#x27;inheritedRoles._id&#x27;: parentName
      },
      {
        $push: {
          inheritedRoles: {
            $each: [
              role._id,
              ...(await Roles._getInheritedRoleNamesAsync(role))
            ].map((r) =&gt; ({ _id: r }))
          }
        }
      },
      { multi: true }
    )
  },

  /**
   * Remove role parent from roles.
   *
   * Other parents are kept (role can have multiple parents). For users which have the
   * parent role set, removed subrole is removed automatically.
   *
   * @method removeRolesFromParentAsync
   * @param {Array|String} rolesNames Name(s) of role(s).
   * @param {String} parentName Name of parent role.
   * @returns {Promise}
   * @static
   */
  removeRolesFromParentAsync: async function (rolesNames, parentName) {
    // ensure arrays
    if (!Array.isArray(rolesNames)) rolesNames = [rolesNames]

    for (const roleName of rolesNames) {
      await Roles._removeRoleFromParentAsync(roleName, parentName)
    }
  },

  /**
   * @method _removeRoleFromParentAsync
   * @param {String} roleName Name of role.
   * @param {String} parentName Name of parent role.
   * @returns {Promise}
   * @private
   * @static
   */
  _removeRoleFromParentAsync: async function (roleName, parentName) {
    Roles._checkRoleName(roleName)
    Roles._checkRoleName(parentName)

    // check for role existence
    // this would not really be needed, but we are trying to match addRolesToParent
    const role = await Meteor.roles.findOneAsync(
      { _id: roleName },
      { fields: { _id: 1 } }
    )

    if (!role) {
      throw new Error(&#x60;Role &#x27;${roleName}&#x27; does not exist.&#x60;)
    }

    const count = await Meteor.roles.updateAsync(
      {
        _id: parentName
      },
      {
        $pull: {
          children: {
            _id: role._id
          }
        }
      }
    )

    // if there was no change, parent role might not exist, or role was
    // already not a subrole; in any case we do not have anything more to do
    if (!count) return

    // For all roles who have had it as a dependency ...
    const roles = [
      ...(await Roles._getParentRoleNamesAsync(
        await Meteor.roles.findOneAsync({ _id: parentName })
      )),
      parentName
    ]

    for (const r of await Meteor.roles
      .find({ _id: { $in: roles } })
      .fetchAsync()) {
      const inheritedRoles = await Roles._getInheritedRoleNamesAsync(
        await Meteor.roles.findOneAsync({ _id: r._id })
      )
      await Meteor.roleAssignment.updateAsync(
        {
          &#x27;role._id&#x27;: r._id,
          &#x27;inheritedRoles._id&#x27;: role._id
        },
        {
          $set: {
            inheritedRoles: [r._id, ...inheritedRoles].map((r2) =&gt; ({
              _id: r2
            }))
          }
        },
        { multi: true }
      )
    }
  },

  /**
   * Add users to roles.
   *
   * Adds roles to existing roles for each user.
   *
   * @example
   *     Roles.addUsersToRolesAsync(userId, &#x27;admin&#x27;)
   *     Roles.addUsersToRolesAsync(userId, [&#x27;view-secrets&#x27;], &#x27;example.com&#x27;)
   *     Roles.addUsersToRolesAsync([user1, user2], [&#x27;user&#x27;,&#x27;editor&#x27;])
   *     Roles.addUsersToRolesAsync([user1, user2], [&#x27;glorious-admin&#x27;, &#x27;perform-action&#x27;], &#x27;example.org&#x27;)
   *
   * @method addUsersToRolesAsync
   * @param {Array|String} users User ID(s) or object(s) with an &#x60;_id&#x60; field.
   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.
   * @param {Object|String} [options] Options:
   *   - &#x60;scope&#x60;: name of the scope, or &#x60;null&#x60; for the global role
   *   - &#x60;ifExists&#x60;: if &#x60;true&#x60;, do not throw an exception if the role does not exist
   * @returns {Promise}
   *
   * Alternatively, it can be a scope name string.
   * @static
   */
  addUsersToRolesAsync: async function (users, roles, options) {
    let id

    if (!users) throw new Error(&quot;Missing &#x27;users&#x27; param.&quot;)
    if (!roles) throw new Error(&quot;Missing &#x27;roles&#x27; param.&quot;)

    options = Roles._normalizeOptions(options)

    // ensure arrays
    if (!Array.isArray(users)) users = [users]
    if (!Array.isArray(roles)) roles = [roles]

    Roles._checkScopeName(options.scope)

    options = Object.assign(
      {
        ifExists: false
      },
      options
    )

    for (const user of users) {
      if (typeof user === &#x27;object&#x27;) {
        id = user._id
      } else {
        id = user
      }

      for (const role of roles) {
        await Roles._addUserToRoleAsync(id, role, options)
      }
    }
  },

  /**
   * Set users&#x27; roles.
   *
   * Replaces all existing roles with a new set of roles.
   *
   * @example
   *     await Roles.setUserRolesAsync(userId, &#x27;admin&#x27;)
   *     await Roles.setUserRolesAsync(userId, [&#x27;view-secrets&#x27;], &#x27;example.com&#x27;)
   *     await Roles.setUserRolesAsync([user1, user2], [&#x27;user&#x27;,&#x27;editor&#x27;])
   *     await Roles.setUserRolesAsync([user1, user2], [&#x27;glorious-admin&#x27;, &#x27;perform-action&#x27;], &#x27;example.org&#x27;)
   *
   * @method setUserRolesAsync
   * @param {Array|String} users User ID(s) or object(s) with an &#x60;_id&#x60; field.
   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.
   * @param {Object|String} [options] Options:
   *   - &#x60;scope&#x60;: name of the scope, or &#x60;null&#x60; for the global role
   *   - &#x60;anyScope&#x60;: if &#x60;true&#x60;, remove all roles the user has, of any scope, if &#x60;false&#x60;, only the one in the same scope
   *   - &#x60;ifExists&#x60;: if &#x60;true&#x60;, do not throw an exception if the role does not exist
   * @returns {Promise}
   *
   * Alternatively, it can be a scope name string.
   * @static
   */
  setUserRolesAsync: async function (users, roles, options) {
    let id

    if (!users) throw new Error(&quot;Missing &#x27;users&#x27; param.&quot;)
    if (!roles) throw new Error(&quot;Missing &#x27;roles&#x27; param.&quot;)

    options = Roles._normalizeOptions(options)

    // ensure arrays
    if (!Array.isArray(users)) users = [users]
    if (!Array.isArray(roles)) roles = [roles]

    Roles._checkScopeName(options.scope)

    options = Object.assign(
      {
        ifExists: false,
        anyScope: false
      },
      options
    )

    for (const user of users) {
      if (typeof user === &#x27;object&#x27;) {
        id = user._id
      } else {
        id = user
      }
      // we first clear all roles for the user
      const selector = { &#x27;user._id&#x27;: id }
      if (!options.anyScope) {
        selector.scope = options.scope
      }

      await Meteor.roleAssignment.removeAsync(selector)

      // and then add all
      for (const role of roles) {
        await Roles._addUserToRoleAsync(id, role, options)
      }
    }
  },

  /**
   * Add one user to one role.
   *
   * @method _addUserToRoleAsync
   * @param {String} userId The user ID.
   * @param {String} roleName Name of the role to add the user to. The role have to exist.
   * @param {Object} options Options:
   *   - &#x60;scope&#x60;: name of the scope, or &#x60;null&#x60; for the global role
   *   - &#x60;ifExists&#x60;: if &#x60;true&#x60;, do not throw an exception if the role does not exist
   * @returns {Promise}
   * @private
   * @static
   */
  _addUserToRoleAsync: async function (userId, roleName, options) {
    Roles._checkRoleName(roleName)
    Roles._checkScopeName(options.scope)

    if (!userId) {
      return
    }

    const role = await Meteor.roles.findOneAsync(
      { _id: roleName },
      { fields: { children: 1 } }
    )

    if (!role) {
      if (options.ifExists) {
        return []
      } else {
        throw new Error(&quot;Role &#x27;&quot; + roleName + &quot;&#x27; does not exist.&quot;)
      }
    }

    // This might create duplicates, because we don&#x27;t have a unique index, but that&#x27;s all right. In case there are two, withdrawing the role will effectively kill them both.
    // TODO revisit this
    /* const res = await RoleAssignmentCollection.upsertAsync(
      {
        &quot;user._id&quot;: userId,
        &quot;role._id&quot;: roleName,
        scope: options.scope,
      },
      {
        $setOnInsert: {
          user: { _id: userId },
          role: { _id: roleName },
          scope: options.scope,
        },
      }
    ); */
    const existingAssignment = await Meteor.roleAssignment.findOneAsync({
      &#x27;user._id&#x27;: userId,
      &#x27;role._id&#x27;: roleName,
      scope: options.scope
    })

    let insertedId
    let res
    if (existingAssignment) {
      await Meteor.roleAssignment.updateAsync(existingAssignment._id, {
        $set: {
          user: { _id: userId },
          role: { _id: roleName },
          scope: options.scope
        }
      })

      res = await Meteor.roleAssignment.findOneAsync(existingAssignment._id)
    } else {
      insertedId = await Meteor.roleAssignment.insertAsync({
        user: { _id: userId },
        role: { _id: roleName },
        scope: options.scope
      })
    }

    if (insertedId) {
      await Meteor.roleAssignment.updateAsync(
        { _id: insertedId },
        {
          $set: {
            inheritedRoles: [
              roleName,
              ...(await Roles._getInheritedRoleNamesAsync(role))
            ].map((r) =&gt; ({ _id: r }))
          }
        }
      )

      res = await Meteor.roleAssignment.findOneAsync({ _id: insertedId })
    }
    res.insertedId = insertedId // For backward compatibility

    return res
  },

  /**
   * Returns an array of role names the given role name is a child of.
   *
   * @example
   *     Roles._getParentRoleNamesAsync({ _id: &#x27;admin&#x27;, children; [] })
   *
   * @method _getParentRoleNamesAsync
   * @param {object} role The role object
   * @returns {Promise}
   * @private
   * @static
   */
  _getParentRoleNamesAsync: async function (role) {
    if (!role) {
      return []
    }

    const parentRoles = new Set([role._id])

    for (const roleName of parentRoles) {
      for (const parentRole of await Meteor.roles
        .find({ &#x27;children._id&#x27;: roleName })
        .fetchAsync()) {
        parentRoles.add(parentRole._id)
      }
    }

    parentRoles.delete(role._id)

    return [...parentRoles]
  },

  /**
   * Returns an array of role names the given role name is a parent of.
   *
   * @example
   *     Roles._getInheritedRoleNames({ _id: &#x27;admin&#x27;, children; [] })
   *
   * @method _getInheritedRoleNames
   * @param {object} role The role object
   * @returns {Promise}
   * @private
   * @static
   */
  _getInheritedRoleNamesAsync: async function (role) {
    const inheritedRoles = new Set()
    const nestedRoles = new Set([role])

    for (const r of nestedRoles) {
      const roles = await Meteor.roles
        .find(
          { _id: { $in: r.children.map((r) =&gt; r._id) } },
          { fields: { children: 1 } }
        )
        .fetchAsync()

      for (const r2 of roles) {
        inheritedRoles.add(r2._id)
        nestedRoles.add(r2)
      }
    }

    return [...inheritedRoles]
  },

  /**
   * Remove users from assigned roles.
   *
   * @example
   *     await Roles.removeUsersFromRolesAsync(userId, &#x27;admin&#x27;)
   *     await Roles.removeUsersFromRolesAsync([userId, user2], [&#x27;editor&#x27;])
   *     await Roles.removeUsersFromRolesAsync(userId, [&#x27;user&#x27;], &#x27;group1&#x27;)
   *
   * @method removeUsersFromRolesAsync
   * @param {Array|String} users User ID(s) or object(s) with an &#x60;_id&#x60; field.
   * @param {Array|String} roles Name(s) of roles to remove users from. Roles have to exist.
   * @param {Object|String} [options] Options:
   *   - &#x60;scope&#x60;: name of the scope, or &#x60;null&#x60; for the global role
   *   - &#x60;anyScope&#x60;: if set, role can be in any scope (&#x60;scope&#x60; option is ignored)
   * @returns {Promise}
   *
   * Alternatively, it can be a scope name string.
   * @static
   */
  removeUsersFromRolesAsync: async function (users, roles, options) {
    if (!users) throw new Error(&quot;Missing &#x27;users&#x27; param.&quot;)
    if (!roles) throw new Error(&quot;Missing &#x27;roles&#x27; param.&quot;)

    options = Roles._normalizeOptions(options)

    // ensure arrays
    if (!Array.isArray(users)) users = [users]
    if (!Array.isArray(roles)) roles = [roles]

    Roles._checkScopeName(options.scope)

    for (const user of users) {
      if (!user) return

      for (const role of roles) {
        let id
        if (typeof user === &#x27;object&#x27;) {
          id = user._id
        } else {
          id = user
        }

        await Roles._removeUserFromRoleAsync(id, role, options)
      }
    }
  },

  /**
   * Remove one user from one role.
   *
   * @method _removeUserFromRoleAsync
   * @param {String} userId The user ID.
   * @param {String} roleName Name of the role to add the user to. The role have to exist.
   * @param {Object} options Options:
   *   - &#x60;scope&#x60;: name of the scope, or &#x60;null&#x60; for the global role
   *   - &#x60;anyScope&#x60;: if set, role can be in any scope (&#x60;scope&#x60; option is ignored)
   * @returns {Promise}
   * @private
   * @static
   */
  _removeUserFromRoleAsync: async function (userId, roleName, options) {
    Roles._checkRoleName(roleName)
    Roles._checkScopeName(options.scope)

    if (!userId) return

    const selector = {
      &#x27;user._id&#x27;: userId,
      &#x27;role._id&#x27;: roleName
    }

    if (!options.anyScope) {
      selector.scope = options.scope
    }

    await Meteor.roleAssignment.removeAsync(selector)
  },

  /**
   * Check if user has specified roles.
   *
   * @example
   *     // global roles
   *     await Roles.userIsInRoleAsync(user, &#x27;admin&#x27;)
   *     await Roles.userIsInRoleAsync(user, [&#x27;admin&#x27;,&#x27;editor&#x27;])
   *     await Roles.userIsInRoleAsync(userId, &#x27;admin&#x27;)
   *     await Roles.userIsInRoleAsync(userId, [&#x27;admin&#x27;,&#x27;editor&#x27;])
   *
   *     // scope roles (global roles are still checked)
   *     await Roles.userIsInRoleAsync(user, &#x27;admin&#x27;, &#x27;group1&#x27;)
   *     await Roles.userIsInRoleAsync(userId, [&#x27;admin&#x27;,&#x27;editor&#x27;], &#x27;group1&#x27;)
   *     await Roles.userIsInRoleAsync(userId, [&#x27;admin&#x27;,&#x27;editor&#x27;], {scope: &#x27;group1&#x27;})
   *
   * @method userIsInRoleAsync
   * @param {String|Object} user User ID or an actual user object.
   * @param {Array|String} roles Name of role or an array of roles to check against. If array,
   *                             will return &#x60;true&#x60; if user is in _any_ role.
   *                             Roles do not have to exist.
   * @param {Object|String} [options] Options:
   *   - &#x60;scope&#x60;: name of the scope; if supplied, limits check to just that scope
   *     the user&#x27;s global roles will always be checked whether scope is specified or not
   *   - &#x60;anyScope&#x60;: if set, role can be in any scope (&#x60;scope&#x60; option is ignored)
   *
   * Alternatively, it can be a scope name string.
   * @return {Promise&lt;Boolean&gt;} &#x60;true&#x60; if user is in _any_ of the target roles
   * @static
   */
  userIsInRoleAsync: async function (user, roles, options) {
    let id

    options = Roles._normalizeOptions(options)

    // ensure array to simplify code
    if (!Array.isArray(roles)) roles = [roles]

    roles = roles.filter((r) =&gt; r != null)

    if (!roles.length) return false

    Roles._checkScopeName(options.scope)

    options = Object.assign(
      {
        anyScope: false
      },
      options
    )

    if (user &amp;&amp; typeof user === &#x27;object&#x27;) {
      id = user._id
    } else {
      id = user
    }

    if (!id) return false
    if (typeof id !== &#x27;string&#x27;) return false

    const selector = {
      &#x27;user._id&#x27;: id
    }

    if (!options.anyScope) {
      selector.scope = { $in: [options.scope, null] }
    }

    const res = await asyncSome(roles, async (roleName) =&gt; {
      selector[&#x27;inheritedRoles._id&#x27;] = roleName
      const out =
        (await Meteor.roleAssignment.countDocuments(selector, { limit: 1 })) &gt; 0
      return out
    })

    return res
  },

  /**
   * Retrieve user&#x27;s roles.
   *
   * @method getRolesForUserAsync
   * @param {String|Object} user User ID or an actual user object.
   * @param {Object|String} [options] Options:
   *   - &#x60;scope&#x60;: name of scope to provide roles for; if not specified, global roles are returned
   *   - &#x60;anyScope&#x60;: if set, role can be in any scope (&#x60;scope&#x60; and &#x60;onlyAssigned&#x60; options are ignored)
   *   - &#x60;onlyScoped&#x60;: if set, only roles in the specified scope are returned
   *   - &#x60;onlyAssigned&#x60;: return only assigned roles and not automatically inferred (like subroles)
   *   - &#x60;fullObjects&#x60;: return full roles objects (&#x60;true&#x60;) or just names (&#x60;false&#x60;) (&#x60;onlyAssigned&#x60; option is ignored) (default &#x60;false&#x60;)
   *     If you have a use-case for this option, please file a feature-request. You shouldn&#x27;t need to use it as it&#x27;s
   *     result strongly dependent on the internal data structure of this plugin.
   *
   * Alternatively, it can be a scope name string.
   * @return {Promise&lt;Array&gt;} Array of user&#x27;s roles, unsorted.
   * @static
   */
  getRolesForUserAsync: async function (user, options) {
    let id

    options = Roles._normalizeOptions(options)

    Roles._checkScopeName(options.scope)

    options = Object.assign({
      fullObjects: false,
      onlyAssigned: false,
      anyScope: false,
      onlyScoped: false
    }, options)

    if (user &amp;&amp; typeof user === &#x27;object&#x27;) {
      id = user._id
    } else {
      id = user
    }

    if (!id) return []

    const selector = {
      &#x27;user._id&#x27;: id
    }

    const filter = {
      fields: { &#x27;inheritedRoles._id&#x27;: 1 }
    }

    if (!options.anyScope) {
      selector.scope = { $in: [options.scope] }

      if (!options.onlyScoped) {
        selector.scope.$in.push(null)
      }
    }

    if (options.onlyAssigned) {
      delete filter.fields[&#x27;inheritedRoles._id&#x27;]
      filter.fields[&#x27;role._id&#x27;] = 1
    }

    if (options.fullObjects) {
      delete filter.fields
    }

    const roles = await Meteor.roleAssignment.find(selector, filter).fetchAsync()

    if (options.fullObjects) {
      return roles
    }

    return [
      ...new Set(
        roles.reduce((rev, current) =&gt; {
          if (current.inheritedRoles) {
            return rev.concat(current.inheritedRoles.map((r) =&gt; r._id))
          } else if (current.role) {
            rev.push(current.role._id)
          }
          return rev
        }, [])
      )
    ]
  },

  /**
   * Retrieve cursor of all existing roles.
   *
   * @method getAllRoles
   * @param {Object} [queryOptions] Options which are passed directly
   *                                through to &#x60;RolesCollection.find(query, options)&#x60;.
   * @return {Cursor} Cursor of existing roles.
   * @static
   */
  getAllRoles: function (queryOptions) {
    queryOptions = queryOptions || { sort: { _id: 1 } }

    return Meteor.roles.find({}, queryOptions)
  },

  /**
   * Retrieve all users who are in target role.
   *
   * Options:
   *
   * @method getUsersInRoleAsync
   * @param {Array|String} roles Name of role or an array of roles. If array, users
   *                             returned will have at least one of the roles
   *                             specified but need not have _all_ roles.
   *                             Roles do not have to exist.
   * @param {Object|String} [options] Options:
   *   - &#x60;scope&#x60;: name of the scope to restrict roles to; user&#x27;s global
   *     roles will also be checked
   *   - &#x60;anyScope&#x60;: if set, role can be in any scope (&#x60;scope&#x60; option is ignored)
   *   - &#x60;onlyScoped&#x60;: if set, only roles in the specified scope are returned
   *   - &#x60;queryOptions&#x60;: options which are passed directly
   *     through to &#x60;Meteor.users.find(query, options)&#x60;
   *
   * Alternatively, it can be a scope name string.
   * @param {Object} [queryOptions] Options which are passed directly
   *                                through to &#x60;Meteor.users.find(query, options)&#x60;
   * @return {Promise&lt;Cursor&gt;} Cursor of users in roles.
   * @static
   */
  getUsersInRoleAsync: async function (roles, options, queryOptions) {
    const ids = (
      await Roles.getUserAssignmentsForRole(roles, options).fetchAsync()
    ).map((a) =&gt; a.user._id)

    return Meteor.users.find(
      { _id: { $in: ids } },
      (options &amp;&amp; options.queryOptions) || queryOptions || {}
    )
  },

  /**
   * Retrieve all assignments of a user which are for the target role.
   *
   * Options:
   *
   * @method getUserAssignmentsForRole
   * @param {Array|String} roles Name of role or an array of roles. If array, users
   *                             returned will have at least one of the roles
   *                             specified but need not have _all_ roles.
   *                             Roles do not have to exist.
   * @param {Object|String} [options] Options:
   *   - &#x60;scope&#x60;: name of the scope to restrict roles to; user&#x27;s global
   *     roles will also be checked
   *   - &#x60;anyScope&#x60;: if set, role can be in any scope (&#x60;scope&#x60; option is ignored)
   *   - &#x60;queryOptions&#x60;: options which are passed directly
   *     through to &#x60;RoleAssignmentCollection.find(query, options)&#x60;

   * Alternatively, it can be a scope name string.
   * @return {Cursor} Cursor of user assignments for roles.
   * @static
   */
  getUserAssignmentsForRole: function (roles, options) {
    options = Roles._normalizeOptions(options)

    options = Object.assign(
      {
        anyScope: false,
        queryOptions: {}
      },
      options
    )

    return Roles._getUsersInRoleCursor(roles, options, options.queryOptions)
  },

  /**
   * @method _getUsersInRoleCursor
   * @param {Array|String} roles Name of role or an array of roles. If array, ids of users are
   *                             returned which have at least one of the roles
   *                             assigned but need not have _all_ roles.
   *                             Roles do not have to exist.
   * @param {Object|String} [options] Options:
   *   - &#x60;scope&#x60;: name of the scope to restrict roles to; user&#x27;s global
   *     roles will also be checked
   *   - &#x60;anyScope&#x60;: if set, role can be in any scope (&#x60;scope&#x60; option is ignored)
   *
   * Alternatively, it can be a scope name string.
   * @param {Object} [filter] Options which are passed directly
   *                                through to &#x60;RoleAssignmentCollection.find(query, options)&#x60;
   * @return {Object} Cursor to the assignment documents
   * @private
   * @static
   */
  _getUsersInRoleCursor: function (roles, options, filter) {
    options = Roles._normalizeOptions(options)

    options = Object.assign(
      {
        anyScope: false,
        onlyScoped: false
      },
      options
    )

    // ensure array to simplify code
    if (!Array.isArray(roles)) roles = [roles]

    Roles._checkScopeName(options.scope)

    filter = Object.assign(
      {
        fields: { &#x27;user._id&#x27;: 1 }
      },
      filter
    )

    const selector = {
      &#x27;inheritedRoles._id&#x27;: { $in: roles }
    }

    if (!options.anyScope) {
      selector.scope = { $in: [options.scope] }

      if (!options.onlyScoped) {
        selector.scope.$in.push(null)
      }
    }

    return Meteor.roleAssignment.find(selector, filter)
  },

  /**
   * Deprecated. Use &#x60;getScopesForUser&#x60; instead.
   *
   * @method getGroupsForUserAsync
   * @returns {Promise&lt;Array&gt;}
   * @static
   * @deprecated
   */
  getGroupsForUserAsync: async function (...args) {
    if (!getGroupsForUserDeprecationWarning) {
      getGroupsForUserDeprecationWarning = true
      console &amp;&amp;
        console.warn(
          &#x27;getGroupsForUser has been deprecated. Use getScopesForUser instead.&#x27;
        )
    }

    return await Roles.getScopesForUser(...args)
  },

  /**
   * Retrieve users scopes, if any.
   *
   * @method getScopesForUserAsync
   * @param {String|Object} user User ID or an actual user object.
   * @param {Array|String} [roles] Name of roles to restrict scopes to.
   *
   * @return {Promise&lt;Array&gt;} Array of user&#x27;s scopes, unsorted.
   * @static
   */
  getScopesForUserAsync: async function (user, roles) {
    let id

    if (roles &amp;&amp; !Array.isArray(roles)) roles = [roles]

    if (user &amp;&amp; typeof user === &#x27;object&#x27;) {
      id = user._id
    } else {
      id = user
    }

    if (!id) return []

    const selector = {
      &#x27;user._id&#x27;: id,
      scope: { $ne: null }
    }

    if (roles) {
      selector[&#x27;inheritedRoles._id&#x27;] = { $in: roles }
    }

    const scopes = (
      await Meteor.roleAssignment
        .find(selector, { fields: { scope: 1 } })
        .fetchAsync()
    ).map((obi) =&gt; obi.scope)

    return [...new Set(scopes)]
  },

  /**
   * Rename a scope.
   *
   * Roles assigned with a given scope are changed to be under the new scope.
   *
   * @method renameScopeAsync
   * @param {String} oldName Old name of a scope.
   * @param {String} newName New name of a scope.
   * @returns {Promise}
   * @static
   */
  renameScopeAsync: async function (oldName, newName) {
    let count

    Roles._checkScopeName(oldName)
    Roles._checkScopeName(newName)

    if (oldName === newName) return

    do {
      count = await Meteor.roleAssignment.updateAsync(
        {
          scope: oldName
        },
        {
          $set: {
            scope: newName
          }
        },
        { multi: true }
      )
    } while (count &gt; 0)
  },

  /**
   * Remove a scope.
   *
   * Roles assigned with a given scope are removed.
   *
   * @method removeScopeAsync
   * @param {String} name The name of a scope.
   * @returns {Promise}
   * @static
   */
  removeScopeAsync: async function (name) {
    Roles._checkScopeName(name)

    await Meteor.roleAssignment.removeAsync({ scope: name })
  },

  /**
   * Throw an exception if &#x60;roleName&#x60; is an invalid role name.
   *
   * @method _checkRoleName
   * @param {String} roleName A role name to match against.
   * @private
   * @static
   */
  _checkRoleName: function (roleName) {
    if (
      !roleName ||
      typeof roleName !== &#x27;string&#x27; ||
      roleName.trim() !== roleName
    ) {
      throw new Error(&#x60;Invalid role name &#x27;${roleName}&#x27;.&#x60;)
    }
  },

  /**
   * Find out if a role is an ancestor of another role.
   *
   * WARNING: If you check this on the client, please make sure all roles are published.
   *
   * @method isParentOfAsync
   * @param {String} parentRoleName The role you want to research.
   * @param {String} childRoleName The role you expect to be among the children of parentRoleName.
   * @returns {Promise}
   * @static
   */
  isParentOfAsync: async function (parentRoleName, childRoleName) {
    if (parentRoleName === childRoleName) {
      return true
    }

    if (parentRoleName == null || childRoleName == null) {
      return false
    }

    Roles._checkRoleName(parentRoleName)
    Roles._checkRoleName(childRoleName)

    let rolesToCheck = [parentRoleName]
    while (rolesToCheck.length !== 0) {
      const roleName = rolesToCheck.pop()

      if (roleName === childRoleName) {
        return true
      }

      const role = await Meteor.roles.findOneAsync({ _id: roleName })

      // This should not happen, but this is a problem to address at some other time.
      if (!role) continue

      rolesToCheck = rolesToCheck.concat(role.children.map((r) =&gt; r._id))
    }

    return false
  },

  /**
   * Normalize options.
   *
   * @method _normalizeOptions
   * @param {Object} options Options to normalize.
   * @return {Object} Normalized options.
   * @private
   * @static
   */
  _normalizeOptions: function (options) {
    options = options === undefined ? {} : options

    // TODO Number will error out on scope validation, we can either error it out here
    // or make it into a string and hence a valid input.
    if (options === null || typeof options === &#x27;string&#x27; || typeof options === &#x27;number&#x27;) {
      options = { scope: options }
    }

    options.scope = Roles._normalizeScopeName(options.scope)

    return options
  },

  /**
   * Normalize scope name.
   *
   * @method _normalizeScopeName
   * @param {String} scopeName A scope name to normalize.
   * @return {String} Normalized scope name.
   * @private
   * @static
   */
  _normalizeScopeName: function (scopeName) {
    // map undefined and null to null
    if (scopeName == null) {
      return null
    } else {
      return scopeName
    }
  },

  /**
   * Throw an exception if &#x60;scopeName&#x60; is an invalid scope name.
   *
   * @method _checkScopeName
   * @param {String} scopeName A scope name to match against.
   * @private
   * @static
   */
  _checkScopeName: function (scopeName) {
    if (scopeName === null) return

    if (
      !scopeName ||
      typeof scopeName !== &#x27;string&#x27; ||
      scopeName.trim() !== scopeName
    ) {
      throw new Error(&#x60;Invalid scope name &#x27;${scopeName}&#x27;.&#x60;)
    }
  }
})

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
